{
  "version": 3,
  "sources": ["../../@langchain/core/src/runnables/passthrough.ts", "../../@langchain/core/src/runnables/router.ts", "../../@langchain/core/src/runnables/branch.ts", "../../@langchain/core/src/runnables/history.ts", "../../@langchain/core/dist/runnables/index.js"],
  "sourcesContent": ["import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n", "import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n", "import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n", "import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(\n      sessionId\n    );\n    return config;\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys } from \"./config.js\";\nimport { Runnable, RunnableAssign, RunnableBinding, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, _coerceToRunnable } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\nimport { RouterRunnable } from \"./router.js\";\nimport { RunnableBranch } from \"./branch.js\";\nimport { RunnableWithMessageHistory } from \"./history.js\";\n\n//#region src/runnables/index.ts\nvar runnables_exports = {};\n__export(runnables_exports, {\n\tRouterRunnable: () => RouterRunnable,\n\tRunnable: () => Runnable,\n\tRunnableAssign: () => RunnableAssign,\n\tRunnableBinding: () => RunnableBinding,\n\tRunnableBranch: () => RunnableBranch,\n\tRunnableEach: () => RunnableEach,\n\tRunnableLambda: () => RunnableLambda,\n\tRunnableMap: () => RunnableMap,\n\tRunnableParallel: () => RunnableParallel,\n\tRunnablePassthrough: () => RunnablePassthrough,\n\tRunnablePick: () => RunnablePick,\n\tRunnableRetry: () => RunnableRetry,\n\tRunnableSequence: () => RunnableSequence,\n\tRunnableToolLike: () => RunnableToolLike,\n\tRunnableWithFallbacks: () => RunnableWithFallbacks,\n\tRunnableWithMessageHistory: () => RunnableWithMessageHistory,\n\t_coerceToRunnable: () => _coerceToRunnable,\n\tensureConfig: () => ensureConfig,\n\tgetCallbackManagerForConfig: () => getCallbackManagerForConfig,\n\tmergeConfigs: () => mergeConfigs,\n\tpatchConfig: () => patchConfig,\n\tpickRunnableConfigKeys: () => pickRunnableConfigKeys\n});\n\n//#endregion\nexport { RouterRunnable, Runnable, RunnableAssign, RunnableBinding, RunnableBranch, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePassthrough, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, RunnableWithMessageHistory, _coerceToRunnable, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys, runnables_exports };\n//# sourceMappingURL=index.js.map"],
  "mappings": "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",
  "names": ["fields?: { func?: RunnablePassthroughFunc<RunInput> }", "input: RunInput", "options?: Partial<RunnableConfig>", "input", "generator: AsyncGenerator<RunInput>", "options: Partial<RunnableConfig>", "finalOutput: RunInput | undefined", "input: AsyncGenerator<RunInput>", "mapping: RunnableMapLike<RunInput, RunOutput>", "fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }", "input: RunInput", "options?: Partial<RunnableConfig>", "inputs: RunInput[]", "options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]", "batchOptions?: RunnableBatchOptions", "i", "fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }", "branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]", "coercedBranches: Branch<RunInput, RunOutput>[]", "input: RunInput", "config?: Partial<RunnableConfig>", "runManager?: CallbackManagerForChainRun", "config: RunnableConfig", "fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>", "historyChain: Runnable", "config", "inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "input: any", "kwargs?: RunnableConfig", "run: Run", "config: RunnableConfig"]
}

import {
  AIMessage,
  BaseMessage,
  ChatMessage,
  HumanMessage,
  Runnable,
  RunnableBinding,
  Serializable,
  SystemMessage,
  __export,
  addLangChainErrorFields,
  coerceMessageLikeToMessage,
  getBufferString,
  isBaseMessage
} from "./chunk-6VIUDLGK.js";
import "./chunk-KDMJ4XM7.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/@langchain/core/dist/prompts/base.js
var BasePromptTemplate = class extends Runnable {
  constructor(input) {
    super(input);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      this._getPromptType()
    ]);
    __publicField(this, "inputVariables");
    __publicField(this, "outputParser");
    __publicField(this, "partialVariables");
    /**
    * Metadata to be used for tracing.
    */
    __publicField(this, "metadata");
    /** Tags to be used for tracing. */
    __publicField(this, "tags");
    const { inputVariables } = input;
    if (inputVariables.includes("stop")) throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
    Object.assign(this, input);
  }
  get lc_attributes() {
    return { partialVariables: void 0 };
  }
  /**
  * Merges partial variables and user variables.
  * @param userVariables The user variables to merge with the partial variables.
  * @returns A Promise that resolves to an object containing the merged variables.
  */
  async mergePartialAndUserVariables(userVariables) {
    const partialVariables = this.partialVariables ?? {};
    const partialValues = {};
    for (const [key, value] of Object.entries(partialVariables)) if (typeof value === "string") partialValues[key] = value;
    else partialValues[key] = await value();
    const allKwargs = {
      ...partialValues,
      ...userVariables
    };
    return allKwargs;
  }
  /**
  * Invokes the prompt template with the given input and options.
  * @param input The input to invoke the prompt template with.
  * @param options Optional configuration for the callback.
  * @returns A Promise that resolves to the output of the prompt template.
  */
  async invoke(input, options) {
    const metadata = {
      ...this.metadata,
      ...options == null ? void 0 : options.metadata
    };
    const tags = [...this.tags ?? [], ...(options == null ? void 0 : options.tags) ?? []];
    return this._callWithConfig((input$1) => this.formatPromptValue(input$1), input, {
      ...options,
      tags,
      metadata,
      runType: "prompt"
    });
  }
};

// node_modules/@langchain/core/dist/prompt_values.js
var prompt_values_exports = {};
__export(prompt_values_exports, {
  BasePromptValue: () => BasePromptValue,
  ChatPromptValue: () => ChatPromptValue,
  ImagePromptValue: () => ImagePromptValue,
  StringPromptValue: () => StringPromptValue
});
var BasePromptValue = class extends Serializable {
};
var StringPromptValue = class extends BasePromptValue {
  constructor(value) {
    super({ value });
    __publicField(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "value");
    this.value = value;
  }
  static lc_name() {
    return "StringPromptValue";
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new HumanMessage(this.value)];
  }
};
var ChatPromptValue = class extends BasePromptValue {
  constructor(fields) {
    if (Array.isArray(fields)) fields = { messages: fields };
    super(fields);
    __publicField(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "messages");
    this.messages = fields.messages;
  }
  static lc_name() {
    return "ChatPromptValue";
  }
  toString() {
    return getBufferString(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
};
var ImagePromptValue = class extends BasePromptValue {
  constructor(fields) {
    if (!("imageUrl" in fields)) fields = { imageUrl: fields };
    super(fields);
    __publicField(this, "lc_namespace", ["langchain_core", "prompt_values"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "imageUrl");
    /** @ignore */
    __publicField(this, "value");
    this.imageUrl = fields.imageUrl;
  }
  static lc_name() {
    return "ImagePromptValue";
  }
  toString() {
    return this.imageUrl.url;
  }
  toChatMessages() {
    return [new HumanMessage({ content: [{
      type: "image_url",
      image_url: {
        detail: this.imageUrl.detail,
        url: this.imageUrl.url
      }
    }] })];
  }
};

// node_modules/@langchain/core/dist/prompts/string.js
var BaseStringPromptTemplate = class extends BasePromptTemplate {
  /**
  * Formats the prompt given the input values and returns a formatted
  * prompt value.
  * @param values The input values to format the prompt.
  * @returns A Promise that resolves to a formatted prompt value.
  */
  async formatPromptValue(values) {
    const formattedPrompt = await this.format(values);
    return new StringPromptValue(formattedPrompt);
  }
};

// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re, string) {
  return regExpTest.call(re, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value = scanner.scanUntil(openingTagRe);
    if (value) {
      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
        chr = value.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value + '" at ' + start);
      if (openSection[1] !== value)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re) {
  var match = this.tail.match(re);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re) {
  var index = this.tail.search(re), match;
  switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value;
  if (cache.hasOwnProperty(name)) {
    value = cache[name];
  } else {
    var context = this, intermediateValue, names, index, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index = 0;
        while (intermediateValue != null && index < names.length) {
          if (index === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
          intermediateValue = intermediateValue[names[index++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value;
  }
  if (isFunction(value))
    value = value.call(this.view);
  return value;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value) {
      this._cache[key] = value;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">") value = this.renderPartial(token, context, partials, config);
    else if (symbol === "&") value = this.unescapedValue(token, context);
    else if (symbol === "name") value = this.escapedValue(token, context, config);
    else if (symbol === "text") value = this.rawValue(token);
    if (value !== void 0)
      buffer += value;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self = this;
  var buffer = "";
  var value = context.lookup(token[1]);
  function subRender(template) {
    return self.render(template, context, partials, config);
  }
  if (!value) return;
  if (isArray(value)) {
    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
    }
  } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
  } else if (isFunction(value)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value != null)
      buffer += value;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value = context.lookup(token[1]);
  if (!value || isArray(value) && value.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials) return;
  var tags = this.getConfigTags(config);
  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value = context.lookup(token[1]);
  if (value != null)
    return value;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value = context.lookup(token[1]);
  if (value != null)
    return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse2(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// node_modules/@langchain/core/dist/prompts/template.js
function configureMustache() {
  mustache_default.escape = (text) => text;
}
var parseFString = (template) => {
  const chars = template.split("");
  const nodes = [];
  const nextBracket = (bracket, start) => {
    for (let i$1 = start; i$1 < chars.length; i$1 += 1) if (bracket.includes(chars[i$1])) return i$1;
    return -1;
  };
  let i = 0;
  while (i < chars.length) if (chars[i] === "{" && i + 1 < chars.length && chars[i + 1] === "{") {
    nodes.push({
      type: "literal",
      text: "{"
    });
    i += 2;
  } else if (chars[i] === "}" && i + 1 < chars.length && chars[i + 1] === "}") {
    nodes.push({
      type: "literal",
      text: "}"
    });
    i += 2;
  } else if (chars[i] === "{") {
    const j = nextBracket("}", i);
    if (j < 0) throw new Error("Unclosed '{' in template.");
    nodes.push({
      type: "variable",
      name: chars.slice(i + 1, j).join("")
    });
    i = j + 1;
  } else if (chars[i] === "}") throw new Error("Single '}' in template.");
  else {
    const next = nextBracket("{}", i);
    const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join("");
    nodes.push({
      type: "literal",
      text
    });
    i = next < 0 ? chars.length : next;
  }
  return nodes;
};
var mustacheTemplateToNodes = (template, context = []) => {
  const nodes = [];
  for (const temp of template) if (temp[0] === "name") {
    const name = temp[1].includes(".") ? temp[1].split(".")[0] : temp[1];
    nodes.push({
      type: "variable",
      name
    });
  } else if ([
    "#",
    "&",
    "^",
    ">"
  ].includes(temp[0])) {
    nodes.push({
      type: "variable",
      name: temp[1]
    });
    if (temp[0] === "#" && temp.length > 4 && Array.isArray(temp[4])) {
      const newContext = [...context, temp[1]];
      const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);
      nodes.push(...nestedNodes);
    }
  } else nodes.push({
    type: "literal",
    text: temp[1]
  });
  return nodes;
};
var parseMustache = (template) => {
  configureMustache();
  const parsed = mustache_default.parse(template);
  return mustacheTemplateToNodes(parsed);
};
var interpolateFString = (template, values) => {
  return parseFString(template).reduce((res, node) => {
    if (node.type === "variable") {
      if (node.name in values) {
        const stringValue = typeof values[node.name] === "string" ? values[node.name] : JSON.stringify(values[node.name]);
        return res + stringValue;
      }
      throw new Error(`(f-string) Missing value for input ${node.name}`);
    }
    return res + node.text;
  }, "");
};
var interpolateMustache = (template, values) => {
  configureMustache();
  return mustache_default.render(template, values);
};
var DEFAULT_FORMATTER_MAPPING = {
  "f-string": interpolateFString,
  mustache: interpolateMustache
};
var DEFAULT_PARSER_MAPPING = {
  "f-string": parseFString,
  mustache: parseMustache
};
var renderTemplate = (template, templateFormat, inputValues) => {
  try {
    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);
  } catch (e) {
    const error = addLangChainErrorFields(e, "INVALID_PROMPT_INPUT");
    throw error;
  }
};
var parseTemplate2 = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);
var checkValidTemplate = (template, templateFormat, inputVariables) => {
  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {
    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);
    throw new Error(`Invalid template format. Got \`${templateFormat}\`;
                         should be one of ${validFormats}`);
  }
  try {
    const dummyInputs = inputVariables.reduce((acc, v) => {
      acc[v] = "foo";
      return acc;
    }, {});
    if (Array.isArray(template)) template.forEach((message) => {
      if (message.type === "text" && "text" in message && typeof message.text === "string") renderTemplate(message.text, templateFormat, dummyInputs);
      else if (message.type === "image_url") {
        if (typeof message.image_url === "string") renderTemplate(message.image_url, templateFormat, dummyInputs);
        else if (typeof message.image_url === "object" && message.image_url !== null && "url" in message.image_url && typeof message.image_url.url === "string") {
          const imageUrl = message.image_url.url;
          renderTemplate(imageUrl, templateFormat, dummyInputs);
        }
      } else throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);
    });
    else renderTemplate(template, templateFormat, dummyInputs);
  } catch (e) {
    throw new Error(`Invalid prompt schema: ${e.message}`);
  }
};

// node_modules/@langchain/core/dist/prompts/prompt.js
var PromptTemplate = class PromptTemplate2 extends BaseStringPromptTemplate {
  constructor(input) {
    super(input);
    __publicField(this, "template");
    __publicField(this, "templateFormat", "f-string");
    __publicField(this, "validateTemplate", true);
    /**
    * Additional fields which should be included inside
    * the message content array if using a complex message
    * content.
    */
    __publicField(this, "additionalContentFields");
    if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
    Object.assign(this, input);
    if (this.validateTemplate) {
      if (this.templateFormat === "mustache") throw new Error("Mustache templates cannot be validated.");
      let totalInputVariables = this.inputVariables;
      if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
      checkValidTemplate(this.template, this.templateFormat, totalInputVariables);
    }
  }
  static lc_name() {
    return "PromptTemplate";
  }
  _getPromptType() {
    return "prompt";
  }
  /**
  * Formats the prompt template with the provided values.
  * @param values The values to be used to format the prompt template.
  * @returns A promise that resolves to a string which is the formatted prompt.
  */
  async format(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    return renderTemplate(this.template, this.templateFormat, allValues);
  }
  /**
  * Take examples in list format with prefix and suffix to create a prompt.
  *
  * Intended to be used a a way to dynamically create a prompt from examples.
  *
  * @param examples - List of examples to use in the prompt.
  * @param suffix - String to go after the list of examples. Should generally set up the user's input.
  * @param inputVariables - A list of variable names the final prompt template will expect
  * @param exampleSeparator - The separator to use in between examples
  * @param prefix - String that should go before any examples. Generally includes examples.
  *
  * @returns The final prompt template generated.
  */
  static fromExamples(examples, suffix, inputVariables, exampleSeparator = "\n\n", prefix = "") {
    const template = [
      prefix,
      ...examples,
      suffix
    ].join(exampleSeparator);
    return new PromptTemplate2({
      inputVariables,
      template
    });
  }
  static fromTemplate(template, options) {
    const { templateFormat = "f-string", ...rest } = options ?? {};
    const names = /* @__PURE__ */ new Set();
    parseTemplate2(template, templateFormat).forEach((node) => {
      if (node.type === "variable") names.add(node.name);
    });
    return new PromptTemplate2({
      inputVariables: [...names],
      templateFormat,
      template,
      ...rest
    });
  }
  /**
  * Partially applies values to the prompt template.
  * @param values The values to be partially applied to the prompt template.
  * @returns A new instance of PromptTemplate with the partially applied values.
  */
  async partial(values) {
    const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new PromptTemplate2(promptDict);
  }
  serialize() {
    if (this.outputParser !== void 0) throw new Error("Cannot serialize a prompt template with an output parser");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      template: this.template,
      template_format: this.templateFormat
    };
  }
  static async deserialize(data) {
    if (!data.template) throw new Error("Prompt template must have a template");
    const res = new PromptTemplate2({
      inputVariables: data.input_variables,
      template: data.template,
      templateFormat: data.template_format
    });
    return res;
  }
};

// node_modules/@langchain/core/dist/prompts/image.js
var ImagePromptTemplate = class ImagePromptTemplate2 extends BasePromptTemplate {
  constructor(input) {
    super(input);
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      "image"
    ]);
    __publicField(this, "template");
    __publicField(this, "templateFormat", "f-string");
    __publicField(this, "validateTemplate", true);
    /**
    * Additional fields which should be included inside
    * the message content array if using a complex message
    * content.
    */
    __publicField(this, "additionalContentFields");
    this.template = input.template;
    this.templateFormat = input.templateFormat ?? this.templateFormat;
    this.validateTemplate = input.validateTemplate ?? this.validateTemplate;
    this.additionalContentFields = input.additionalContentFields;
    if (this.validateTemplate) {
      let totalInputVariables = this.inputVariables;
      if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
      checkValidTemplate([{
        type: "image_url",
        image_url: this.template
      }], this.templateFormat, totalInputVariables);
    }
  }
  static lc_name() {
    return "ImagePromptTemplate";
  }
  _getPromptType() {
    return "prompt";
  }
  /**
  * Partially applies values to the prompt template.
  * @param values The values to be partially applied to the prompt template.
  * @returns A new instance of ImagePromptTemplate with the partially applied values.
  */
  async partial(values) {
    const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new ImagePromptTemplate2(promptDict);
  }
  /**
  * Formats the prompt template with the provided values.
  * @param values The values to be used to format the prompt template.
  * @returns A promise that resolves to a string which is the formatted prompt.
  */
  async format(values) {
    const formatted = {};
    for (const [key, value] of Object.entries(this.template)) if (typeof value === "string") formatted[key] = renderTemplate(value, this.templateFormat, values);
    else formatted[key] = value;
    const url = values.url || formatted.url;
    const detail = values.detail || formatted.detail;
    if (!url) throw new Error("Must provide either an image URL.");
    if (typeof url !== "string") throw new Error("url must be a string.");
    const output = { url };
    if (detail) output.detail = detail;
    return output;
  }
  /**
  * Formats the prompt given the input values and returns a formatted
  * prompt value.
  * @param values The input values to format the prompt.
  * @returns A Promise that resolves to a formatted prompt value.
  */
  async formatPromptValue(values) {
    const formattedPrompt = await this.format(values);
    return new ImagePromptValue(formattedPrompt);
  }
};

// node_modules/@langchain/core/dist/prompts/dict.js
var DictPromptTemplate = class extends Runnable {
  constructor(fields) {
    const templateFormat = fields.templateFormat ?? "f-string";
    const inputVariables = _getInputVariables(fields.template, templateFormat);
    super({
      inputVariables,
      ...fields
    });
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      "dict"
    ]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "template");
    __publicField(this, "templateFormat");
    __publicField(this, "inputVariables");
    this.template = fields.template;
    this.templateFormat = templateFormat;
    this.inputVariables = inputVariables;
  }
  static lc_name() {
    return "DictPromptTemplate";
  }
  async format(values) {
    return _insertInputVariables(this.template, values, this.templateFormat);
  }
  async invoke(values) {
    return await this._callWithConfig(this.format.bind(this), values, { runType: "prompt" });
  }
};
function _getInputVariables(template, templateFormat) {
  const inputVariables = [];
  for (const v of Object.values(template)) if (typeof v === "string") parseTemplate2(v, templateFormat).forEach((t) => {
    if (t.type === "variable") inputVariables.push(t.name);
  });
  else if (Array.isArray(v)) {
    for (const x of v) if (typeof x === "string") parseTemplate2(x, templateFormat).forEach((t) => {
      if (t.type === "variable") inputVariables.push(t.name);
    });
    else if (typeof x === "object") inputVariables.push(..._getInputVariables(x, templateFormat));
  } else if (typeof v === "object" && v !== null) inputVariables.push(..._getInputVariables(v, templateFormat));
  return Array.from(new Set(inputVariables));
}
function _insertInputVariables(template, inputs, templateFormat) {
  const formatted = {};
  for (const [k, v] of Object.entries(template)) if (typeof v === "string") formatted[k] = renderTemplate(v, templateFormat, inputs);
  else if (Array.isArray(v)) {
    const formattedV = [];
    for (const x of v) if (typeof x === "string") formattedV.push(renderTemplate(x, templateFormat, inputs));
    else if (typeof x === "object") formattedV.push(_insertInputVariables(x, inputs, templateFormat));
    formatted[k] = formattedV;
  } else if (typeof v === "object" && v !== null) formatted[k] = _insertInputVariables(v, inputs, templateFormat);
  else formatted[k] = v;
  return formatted;
}

// node_modules/@langchain/core/dist/prompts/chat.js
var BaseMessagePromptTemplate = class extends Runnable {
  constructor() {
    super(...arguments);
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      "chat"
    ]);
    __publicField(this, "lc_serializable", true);
  }
  /**
  * Calls the formatMessages method with the provided input and options.
  * @param input Input for the formatMessages method
  * @param options Optional BaseCallbackConfig
  * @returns Formatted output messages
  */
  async invoke(input, options) {
    return this._callWithConfig((input$1) => this.formatMessages(input$1), input, {
      ...options,
      runType: "prompt"
    });
  }
};
var MessagesPlaceholder = class extends BaseMessagePromptTemplate {
  constructor(fields) {
    if (typeof fields === "string") fields = { variableName: fields };
    super(fields);
    __publicField(this, "variableName");
    __publicField(this, "optional");
    this.variableName = fields.variableName;
    this.optional = fields.optional ?? false;
  }
  static lc_name() {
    return "MessagesPlaceholder";
  }
  get inputVariables() {
    return [this.variableName];
  }
  async formatMessages(values) {
    const input = values[this.variableName];
    if (this.optional && !input) return [];
    else if (!input) {
      const error = new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
      error.name = "InputFormatError";
      throw error;
    }
    let formattedMessages;
    try {
      if (Array.isArray(input)) formattedMessages = input.map(coerceMessageLikeToMessage);
      else formattedMessages = [coerceMessageLikeToMessage(input)];
    } catch (e) {
      const readableInput = typeof input === "string" ? input : JSON.stringify(input, null, 2);
      const error = new Error([
        `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
        `Received value: ${readableInput}`,
        `Additional message: ${e.message}`
      ].join("\n\n"));
      error.name = "InputFormatError";
      error.lc_error_code = e.lc_error_code;
      throw error;
    }
    return formattedMessages;
  }
};
var BaseMessageStringPromptTemplate = class extends BaseMessagePromptTemplate {
  constructor(fields) {
    if (!("prompt" in fields)) fields = { prompt: fields };
    super(fields);
    __publicField(this, "prompt");
    this.prompt = fields.prompt;
  }
  get inputVariables() {
    return this.prompt.inputVariables;
  }
  async formatMessages(values) {
    return [await this.format(values)];
  }
};
var BaseChatPromptTemplate = class extends BasePromptTemplate {
  constructor(input) {
    super(input);
  }
  async format(values) {
    return (await this.formatPromptValue(values)).toString();
  }
  async formatPromptValue(values) {
    const resultMessages = await this.formatMessages(values);
    return new ChatPromptValue(resultMessages);
  }
};
var ChatMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
  constructor(fields, role) {
    if (!("prompt" in fields)) fields = {
      prompt: fields,
      role
    };
    super(fields);
    __publicField(this, "role");
    this.role = fields.role;
  }
  static lc_name() {
    return "ChatMessagePromptTemplate";
  }
  async format(values) {
    return new ChatMessage(await this.prompt.format(values), this.role);
  }
  static fromTemplate(template, role, options) {
    return new this(PromptTemplate.fromTemplate(template, { templateFormat: options == null ? void 0 : options.templateFormat }), role);
  }
};
function isTextTemplateParam(param) {
  if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
  return Object.keys(param).length === 1 && "text" in param && typeof param.text === "string";
}
function isImageTemplateParam(param) {
  if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
  return "image_url" in param && (typeof param.image_url === "string" || typeof param.image_url === "object" && param.image_url !== null && "url" in param.image_url && typeof param.image_url.url === "string");
}
var _StringImageMessagePromptTemplate = class extends BaseMessagePromptTemplate {
  constructor(fields, additionalOptions) {
    if (!("prompt" in fields)) fields = { prompt: fields };
    super(fields);
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      "chat"
    ]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "inputVariables", []);
    __publicField(this, "additionalOptions", {});
    __publicField(this, "prompt");
    __publicField(this, "messageClass");
    __publicField(this, "chatMessageClass");
    this.prompt = fields.prompt;
    if (Array.isArray(this.prompt)) {
      let inputVariables = [];
      this.prompt.forEach((prompt) => {
        if ("inputVariables" in prompt) inputVariables = inputVariables.concat(prompt.inputVariables);
      });
      this.inputVariables = inputVariables;
    } else this.inputVariables = this.prompt.inputVariables;
    this.additionalOptions = additionalOptions ?? this.additionalOptions;
  }
  static _messageClass() {
    throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
  }
  createMessage(content) {
    const constructor = this.constructor;
    if (constructor._messageClass()) {
      const MsgClass = constructor._messageClass();
      return new MsgClass({ content });
    } else if (constructor.chatMessageClass) {
      const MsgClass = constructor.chatMessageClass();
      return new MsgClass({
        content,
        role: this.getRoleFromMessageClass(MsgClass.lc_name())
      });
    } else throw new Error("No message class defined");
  }
  getRoleFromMessageClass(name) {
    switch (name) {
      case "HumanMessage":
        return "human";
      case "AIMessage":
        return "ai";
      case "SystemMessage":
        return "system";
      case "ChatMessage":
        return "chat";
      default:
        throw new Error("Invalid message class name");
    }
  }
  static fromTemplate(template, additionalOptions) {
    if (typeof template === "string") return new this(PromptTemplate.fromTemplate(template, additionalOptions));
    const prompt = [];
    for (const item of template) if (typeof item === "string") prompt.push(PromptTemplate.fromTemplate(item, additionalOptions));
    else if (item === null) {
    } else if (isTextTemplateParam(item)) {
      let text = "";
      if (typeof item.text === "string") text = item.text ?? "";
      const options = {
        ...additionalOptions,
        additionalContentFields: item
      };
      prompt.push(PromptTemplate.fromTemplate(text, options));
    } else if (isImageTemplateParam(item)) {
      let imgTemplate = item.image_url ?? "";
      let imgTemplateObject;
      let inputVariables = [];
      if (typeof imgTemplate === "string") {
        let parsedTemplate;
        if ((additionalOptions == null ? void 0 : additionalOptions.templateFormat) === "mustache") parsedTemplate = parseMustache(imgTemplate);
        else parsedTemplate = parseFString(imgTemplate);
        const variables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
        if (((variables == null ? void 0 : variables.length) ?? 0) > 0) {
          if (variables.length > 1) throw new Error(`Only one format variable allowed per image template.
Got: ${variables}
From: ${imgTemplate}`);
          inputVariables = [variables[0]];
        } else inputVariables = [];
        imgTemplate = { url: imgTemplate };
        imgTemplateObject = new ImagePromptTemplate({
          template: imgTemplate,
          inputVariables,
          templateFormat: additionalOptions == null ? void 0 : additionalOptions.templateFormat,
          additionalContentFields: item
        });
      } else if (typeof imgTemplate === "object") {
        if ("url" in imgTemplate) {
          let parsedTemplate;
          if ((additionalOptions == null ? void 0 : additionalOptions.templateFormat) === "mustache") parsedTemplate = parseMustache(imgTemplate.url);
          else parsedTemplate = parseFString(imgTemplate.url);
          inputVariables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
        } else inputVariables = [];
        imgTemplateObject = new ImagePromptTemplate({
          template: imgTemplate,
          inputVariables,
          templateFormat: additionalOptions == null ? void 0 : additionalOptions.templateFormat,
          additionalContentFields: item
        });
      } else throw new Error("Invalid image template");
      prompt.push(imgTemplateObject);
    } else if (typeof item === "object") prompt.push(new DictPromptTemplate({
      template: item,
      templateFormat: additionalOptions == null ? void 0 : additionalOptions.templateFormat
    }));
    return new this({
      prompt,
      additionalOptions
    });
  }
  async format(input) {
    if (this.prompt instanceof BaseStringPromptTemplate) {
      const text = await this.prompt.format(input);
      return this.createMessage(text);
    } else {
      const content = [];
      for (const prompt of this.prompt) {
        let inputs = {};
        if (!("inputVariables" in prompt)) throw new Error(`Prompt ${prompt} does not have inputVariables defined.`);
        for (const item of prompt.inputVariables) {
          if (!inputs) inputs = { [item]: input[item] };
          inputs = {
            ...inputs,
            [item]: input[item]
          };
        }
        if (prompt instanceof BaseStringPromptTemplate) {
          const formatted = await prompt.format(inputs);
          let additionalContentFields;
          if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
          if (formatted !== "") content.push({
            ...additionalContentFields,
            type: "text",
            text: formatted
          });
        } else if (prompt instanceof ImagePromptTemplate) {
          const formatted = await prompt.format(inputs);
          let additionalContentFields;
          if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
          content.push({
            ...additionalContentFields,
            type: "image_url",
            image_url: formatted
          });
        } else if (prompt instanceof DictPromptTemplate) {
          const formatted = await prompt.format(inputs);
          let additionalContentFields;
          if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
          content.push({
            ...additionalContentFields,
            ...formatted
          });
        }
      }
      return this.createMessage(content);
    }
  }
  async formatMessages(values) {
    return [await this.format(values)];
  }
};
var HumanMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
  static _messageClass() {
    return HumanMessage;
  }
  static lc_name() {
    return "HumanMessagePromptTemplate";
  }
};
var AIMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
  static _messageClass() {
    return AIMessage;
  }
  static lc_name() {
    return "AIMessagePromptTemplate";
  }
};
var SystemMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
  static _messageClass() {
    return SystemMessage;
  }
  static lc_name() {
    return "SystemMessagePromptTemplate";
  }
};
function _isBaseMessagePromptTemplate(baseMessagePromptTemplateLike) {
  return typeof baseMessagePromptTemplateLike.formatMessages === "function";
}
function _coerceMessagePromptTemplateLike(messagePromptTemplateLike, extra) {
  if (_isBaseMessagePromptTemplate(messagePromptTemplateLike) || isBaseMessage(messagePromptTemplateLike)) return messagePromptTemplateLike;
  if (Array.isArray(messagePromptTemplateLike) && messagePromptTemplateLike[0] === "placeholder") {
    const messageContent = messagePromptTemplateLike[1];
    if ((extra == null ? void 0 : extra.templateFormat) === "mustache" && typeof messageContent === "string" && messageContent.slice(0, 2) === "{{" && messageContent.slice(-2) === "}}") {
      const variableName = messageContent.slice(2, -2);
      return new MessagesPlaceholder({
        variableName,
        optional: true
      });
    } else if (typeof messageContent === "string" && messageContent[0] === "{" && messageContent[messageContent.length - 1] === "}") {
      const variableName = messageContent.slice(1, -1);
      return new MessagesPlaceholder({
        variableName,
        optional: true
      });
    }
    throw new Error(`Invalid placeholder template for format ${(extra == null ? void 0 : extra.templateFormat) ?? `"f-string"`}: "${messagePromptTemplateLike[1]}". Expected a variable name surrounded by ${(extra == null ? void 0 : extra.templateFormat) === "mustache" ? "double" : "single"} curly braces.`);
  }
  const message = coerceMessageLikeToMessage(messagePromptTemplateLike);
  let templateData;
  if (typeof message.content === "string") templateData = message.content;
  else templateData = message.content.map((item) => {
    if ("text" in item) return {
      ...item,
      text: item.text
    };
    else if ("image_url" in item) return {
      ...item,
      image_url: item.image_url
    };
    else return item;
  });
  if (message._getType() === "human") return HumanMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (message._getType() === "ai") return AIMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (message._getType() === "system") return SystemMessagePromptTemplate.fromTemplate(templateData, extra);
  else if (ChatMessage.isInstance(message)) return ChatMessagePromptTemplate.fromTemplate(message.content, message.role, extra);
  else throw new Error(`Could not coerce message prompt template from input. Received message type: "${message._getType()}".`);
}
function isMessagesPlaceholder(x) {
  return x.constructor.lc_name() === "MessagesPlaceholder";
}
var ChatPromptTemplate = class ChatPromptTemplate2 extends BaseChatPromptTemplate {
  constructor(input) {
    super(input);
    __publicField(this, "promptMessages");
    __publicField(this, "validateTemplate", true);
    __publicField(this, "templateFormat", "f-string");
    if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
    Object.assign(this, input);
    if (this.validateTemplate) {
      const inputVariablesMessages = /* @__PURE__ */ new Set();
      for (const promptMessage of this.promptMessages) {
        if (promptMessage instanceof BaseMessage) continue;
        for (const inputVariable of promptMessage.inputVariables) inputVariablesMessages.add(inputVariable);
      }
      const totalInputVariables = this.inputVariables;
      const inputVariablesInstance = new Set(this.partialVariables ? totalInputVariables.concat(Object.keys(this.partialVariables)) : totalInputVariables);
      const difference = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)));
      if (difference.size > 0) throw new Error(`Input variables \`${[...difference]}\` are not used in any of the prompt messages.`);
      const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)));
      if (otherDifference.size > 0) throw new Error(`Input variables \`${[...otherDifference]}\` are used in prompt messages but not in the prompt template.`);
    }
  }
  static lc_name() {
    return "ChatPromptTemplate";
  }
  get lc_aliases() {
    return { promptMessages: "messages" };
  }
  _getPromptType() {
    return "chat";
  }
  async _parseImagePrompts(message, inputValues) {
    if (typeof message.content === "string") return message;
    const formattedMessageContent = await Promise.all(message.content.map(async (item) => {
      if (item.type !== "image_url") return item;
      let imageUrl = "";
      if (typeof item.image_url === "string") imageUrl = item.image_url;
      else if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url && typeof item.image_url.url === "string") imageUrl = item.image_url.url;
      const promptTemplatePlaceholder = PromptTemplate.fromTemplate(imageUrl, { templateFormat: this.templateFormat });
      const formattedUrl = await promptTemplatePlaceholder.format(inputValues);
      if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url) item.image_url.url = formattedUrl;
      else item.image_url = formattedUrl;
      return item;
    }));
    message.content = formattedMessageContent;
    return message;
  }
  async formatMessages(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    let resultMessages = [];
    for (const promptMessage of this.promptMessages) if (promptMessage instanceof BaseMessage) resultMessages.push(await this._parseImagePrompts(promptMessage, allValues));
    else {
      let inputValues;
      if (this.templateFormat === "mustache") inputValues = { ...allValues };
      else inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {
        if (!(inputVariable in allValues) && !(isMessagesPlaceholder(promptMessage) && promptMessage.optional)) {
          const error = addLangChainErrorFields(new Error(`Missing value for input variable \`${inputVariable.toString()}\``), "INVALID_PROMPT_INPUT");
          throw error;
        }
        acc[inputVariable] = allValues[inputVariable];
        return acc;
      }, {});
      const message = await promptMessage.formatMessages(inputValues);
      resultMessages = resultMessages.concat(message);
    }
    return resultMessages;
  }
  async partial(values) {
    const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new ChatPromptTemplate2(promptDict);
  }
  static fromTemplate(template, options) {
    const prompt = PromptTemplate.fromTemplate(template, options);
    const humanTemplate = new HumanMessagePromptTemplate({ prompt });
    return this.fromMessages([humanTemplate]);
  }
  /**
  * Create a chat model-specific prompt from individual chat messages
  * or message-like tuples.
  * @param promptMessages Messages to be passed to the chat model
  * @returns A new ChatPromptTemplate
  */
  static fromMessages(promptMessages, extra) {
    const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(promptMessage instanceof ChatPromptTemplate2 ? promptMessage.promptMessages : [_coerceMessagePromptTemplateLike(promptMessage, extra)]), []);
    const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => promptMessage instanceof ChatPromptTemplate2 ? Object.assign(acc, promptMessage.partialVariables) : acc, /* @__PURE__ */ Object.create(null));
    const inputVariables = /* @__PURE__ */ new Set();
    for (const promptMessage of flattenedMessages) {
      if (promptMessage instanceof BaseMessage) continue;
      for (const inputVariable of promptMessage.inputVariables) {
        if (inputVariable in flattenedPartialVariables) continue;
        inputVariables.add(inputVariable);
      }
    }
    return new this({
      ...extra,
      inputVariables: [...inputVariables],
      promptMessages: flattenedMessages,
      partialVariables: flattenedPartialVariables,
      templateFormat: extra == null ? void 0 : extra.templateFormat
    });
  }
};

// node_modules/@langchain/core/dist/prompts/few_shot.js
var FewShotPromptTemplate = class FewShotPromptTemplate2 extends BaseStringPromptTemplate {
  constructor(input) {
    super(input);
    __publicField(this, "lc_serializable", false);
    __publicField(this, "examples");
    __publicField(this, "exampleSelector");
    __publicField(this, "examplePrompt");
    __publicField(this, "suffix", "");
    __publicField(this, "exampleSeparator", "\n\n");
    __publicField(this, "prefix", "");
    __publicField(this, "templateFormat", "f-string");
    __publicField(this, "validateTemplate", true);
    Object.assign(this, input);
    if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
    if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
    if (this.validateTemplate) {
      let totalInputVariables = this.inputVariables;
      if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
      checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
    }
  }
  _getPromptType() {
    return "few_shot";
  }
  static lc_name() {
    return "FewShotPromptTemplate";
  }
  async getExamples(inputVariables) {
    if (this.examples !== void 0) return this.examples;
    if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
    throw new Error("One of 'examples' and 'example_selector' should be provided");
  }
  async partial(values) {
    const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new FewShotPromptTemplate2(promptDict);
  }
  /**
  * Formats the prompt with the given values.
  * @param values The values to format the prompt with.
  * @returns A promise that resolves to a string representing the formatted prompt.
  */
  async format(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    const examples = await this.getExamples(allValues);
    const exampleStrings = await Promise.all(examples.map((example) => this.examplePrompt.format(example)));
    const template = [
      this.prefix,
      ...exampleStrings,
      this.suffix
    ].join(this.exampleSeparator);
    return renderTemplate(template, this.templateFormat, allValues);
  }
  serialize() {
    if (this.exampleSelector || !this.examples) throw new Error("Serializing an example selector is not currently supported");
    if (this.outputParser !== void 0) throw new Error("Serializing an output parser is not currently supported");
    return {
      _type: this._getPromptType(),
      input_variables: this.inputVariables,
      example_prompt: this.examplePrompt.serialize(),
      example_separator: this.exampleSeparator,
      suffix: this.suffix,
      prefix: this.prefix,
      template_format: this.templateFormat,
      examples: this.examples
    };
  }
  static async deserialize(data) {
    const { example_prompt } = data;
    if (!example_prompt) throw new Error("Missing example prompt");
    const examplePrompt = await PromptTemplate.deserialize(example_prompt);
    let examples;
    if (Array.isArray(data.examples)) examples = data.examples;
    else throw new Error("Invalid examples format. Only list or string are supported.");
    return new FewShotPromptTemplate2({
      inputVariables: data.input_variables,
      examplePrompt,
      examples,
      exampleSeparator: data.example_separator,
      prefix: data.prefix,
      suffix: data.suffix,
      templateFormat: data.template_format
    });
  }
};
var FewShotChatMessagePromptTemplate = class FewShotChatMessagePromptTemplate2 extends BaseChatPromptTemplate {
  constructor(fields) {
    super(fields);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "examples");
    __publicField(this, "exampleSelector");
    __publicField(this, "examplePrompt");
    __publicField(this, "suffix", "");
    __publicField(this, "exampleSeparator", "\n\n");
    __publicField(this, "prefix", "");
    __publicField(this, "templateFormat", "f-string");
    __publicField(this, "validateTemplate", true);
    this.examples = fields.examples;
    this.examplePrompt = fields.examplePrompt;
    this.exampleSeparator = fields.exampleSeparator ?? "\n\n";
    this.exampleSelector = fields.exampleSelector;
    this.prefix = fields.prefix ?? "";
    this.suffix = fields.suffix ?? "";
    this.templateFormat = fields.templateFormat ?? "f-string";
    this.validateTemplate = fields.validateTemplate ?? true;
    if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
    if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
    if (this.validateTemplate) {
      let totalInputVariables = this.inputVariables;
      if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
      checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
    }
  }
  _getPromptType() {
    return "few_shot_chat";
  }
  static lc_name() {
    return "FewShotChatMessagePromptTemplate";
  }
  async getExamples(inputVariables) {
    if (this.examples !== void 0) return this.examples;
    if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
    throw new Error("One of 'examples' and 'example_selector' should be provided");
  }
  /**
  * Formats the list of values and returns a list of formatted messages.
  * @param values The values to format the prompt with.
  * @returns A promise that resolves to a string representing the formatted prompt.
  */
  async formatMessages(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    let examples = await this.getExamples(allValues);
    examples = examples.map((example) => {
      const result = {};
      this.examplePrompt.inputVariables.forEach((inputVariable) => {
        result[inputVariable] = example[inputVariable];
      });
      return result;
    });
    const messages = [];
    for (const example of examples) {
      const exampleMessages = await this.examplePrompt.formatMessages(example);
      messages.push(...exampleMessages);
    }
    return messages;
  }
  /**
  * Formats the prompt with the given values.
  * @param values The values to format the prompt with.
  * @returns A promise that resolves to a string representing the formatted prompt.
  */
  async format(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    const examples = await this.getExamples(allValues);
    const exampleMessages = await Promise.all(examples.map((example) => this.examplePrompt.formatMessages(example)));
    const exampleStrings = exampleMessages.flat().map((message) => message.content);
    const template = [
      this.prefix,
      ...exampleStrings,
      this.suffix
    ].join(this.exampleSeparator);
    return renderTemplate(template, this.templateFormat, allValues);
  }
  /**
  * Partially formats the prompt with the given values.
  * @param values The values to partially format the prompt with.
  * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.
  */
  async partial(values) {
    const newInputVariables = this.inputVariables.filter((variable) => !(variable in values));
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new FewShotChatMessagePromptTemplate2(promptDict);
  }
};

// node_modules/@langchain/core/dist/prompts/pipeline.js
var PipelinePromptTemplate = class PipelinePromptTemplate2 extends BasePromptTemplate {
  constructor(input) {
    super({
      ...input,
      inputVariables: []
    });
    __publicField(this, "pipelinePrompts");
    __publicField(this, "finalPrompt");
    this.pipelinePrompts = input.pipelinePrompts;
    this.finalPrompt = input.finalPrompt;
    this.inputVariables = this.computeInputValues();
  }
  static lc_name() {
    return "PipelinePromptTemplate";
  }
  /**
  * Computes the input values required by the pipeline prompts.
  * @returns Array of input values required by the pipeline prompts.
  */
  computeInputValues() {
    const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);
    const inputValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue))).flat();
    return [...new Set(inputValues)];
  }
  static extractRequiredInputValues(allValues, requiredValueNames) {
    return requiredValueNames.reduce((requiredValues, valueName) => {
      requiredValues[valueName] = allValues[valueName];
      return requiredValues;
    }, {});
  }
  /**
  * Formats the pipeline prompts based on the provided input values.
  * @param values Input values to format the pipeline prompts.
  * @returns Promise that resolves with the formatted input values.
  */
  async formatPipelinePrompts(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts) {
      const pipelinePromptInputValues = PipelinePromptTemplate2.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
      if (pipelinePrompt instanceof ChatPromptTemplate) allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
      else allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
    }
    return PipelinePromptTemplate2.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
  }
  /**
  * Formats the final prompt value based on the provided input values.
  * @param values Input values to format the final prompt value.
  * @returns Promise that resolves with the formatted final prompt value.
  */
  async formatPromptValue(values) {
    return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
  }
  async format(values) {
    return this.finalPrompt.format(await this.formatPipelinePrompts(values));
  }
  /**
  * Handles partial prompts, which are prompts that have been partially
  * filled with input values.
  * @param values Partial input values.
  * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.
  */
  async partial(values) {
    const promptDict = { ...this };
    promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
    promptDict.partialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    return new PipelinePromptTemplate2(promptDict);
  }
  serialize() {
    throw new Error("Not implemented.");
  }
  _getPromptType() {
    return "pipeline";
  }
};

// node_modules/@langchain/core/dist/prompts/structured.js
function isWithStructuredOutput(x) {
  return typeof x === "object" && x != null && "withStructuredOutput" in x && typeof x.withStructuredOutput === "function";
}
function isRunnableBinding(x) {
  return typeof x === "object" && x != null && "lc_id" in x && Array.isArray(x.lc_id) && x.lc_id.join("/") === "langchain_core/runnables/RunnableBinding";
}
var StructuredPrompt = class StructuredPrompt2 extends ChatPromptTemplate {
  constructor(input) {
    super(input);
    __publicField(this, "schema");
    __publicField(this, "method");
    __publicField(this, "lc_namespace", [
      "langchain_core",
      "prompts",
      "structured"
    ]);
    this.schema = input.schema;
    this.method = input.method;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      schema: "schema_"
    };
  }
  pipe(coerceable) {
    if (isWithStructuredOutput(coerceable)) return super.pipe(coerceable.withStructuredOutput(this.schema));
    if (isRunnableBinding(coerceable) && isWithStructuredOutput(coerceable.bound)) return super.pipe(new RunnableBinding({
      bound: coerceable.bound.withStructuredOutput(this.schema, ...this.method ? [{ method: this.method }] : []),
      kwargs: coerceable.kwargs ?? {},
      config: coerceable.config,
      configFactories: coerceable.configFactories
    }));
    throw new Error(`Structured prompts need to be piped to a language model that supports the "withStructuredOutput()" method.`);
  }
  static fromMessagesAndSchema(promptMessages, schema, method) {
    return StructuredPrompt2.fromMessages(promptMessages, {
      schema,
      method
    });
  }
};

// node_modules/@langchain/core/dist/prompts/index.js
var prompts_exports = {};
__export(prompts_exports, {
  AIMessagePromptTemplate: () => AIMessagePromptTemplate,
  BaseChatPromptTemplate: () => BaseChatPromptTemplate,
  BaseMessagePromptTemplate: () => BaseMessagePromptTemplate,
  BaseMessageStringPromptTemplate: () => BaseMessageStringPromptTemplate,
  BasePromptTemplate: () => BasePromptTemplate,
  BaseStringPromptTemplate: () => BaseStringPromptTemplate,
  ChatMessagePromptTemplate: () => ChatMessagePromptTemplate,
  ChatPromptTemplate: () => ChatPromptTemplate,
  DEFAULT_FORMATTER_MAPPING: () => DEFAULT_FORMATTER_MAPPING,
  DEFAULT_PARSER_MAPPING: () => DEFAULT_PARSER_MAPPING,
  DictPromptTemplate: () => DictPromptTemplate,
  FewShotChatMessagePromptTemplate: () => FewShotChatMessagePromptTemplate,
  FewShotPromptTemplate: () => FewShotPromptTemplate,
  HumanMessagePromptTemplate: () => HumanMessagePromptTemplate,
  ImagePromptTemplate: () => ImagePromptTemplate,
  MessagesPlaceholder: () => MessagesPlaceholder,
  PipelinePromptTemplate: () => PipelinePromptTemplate,
  PromptTemplate: () => PromptTemplate,
  StructuredPrompt: () => StructuredPrompt,
  SystemMessagePromptTemplate: () => SystemMessagePromptTemplate,
  checkValidTemplate: () => checkValidTemplate,
  interpolateFString: () => interpolateFString,
  interpolateMustache: () => interpolateMustache,
  parseFString: () => parseFString,
  parseMustache: () => parseMustache,
  parseTemplate: () => parseTemplate2,
  renderTemplate: () => renderTemplate
});
export {
  AIMessagePromptTemplate,
  BaseChatPromptTemplate,
  BaseMessagePromptTemplate,
  BaseMessageStringPromptTemplate,
  BasePromptTemplate,
  BaseStringPromptTemplate,
  ChatMessagePromptTemplate,
  ChatPromptTemplate,
  DEFAULT_FORMATTER_MAPPING,
  DEFAULT_PARSER_MAPPING,
  DictPromptTemplate,
  FewShotChatMessagePromptTemplate,
  FewShotPromptTemplate,
  HumanMessagePromptTemplate,
  ImagePromptTemplate,
  MessagesPlaceholder,
  PipelinePromptTemplate,
  PromptTemplate,
  StructuredPrompt,
  SystemMessagePromptTemplate,
  checkValidTemplate,
  interpolateFString,
  interpolateMustache,
  parseFString,
  parseMustache,
  parseTemplate2 as parseTemplate,
  prompts_exports,
  renderTemplate
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=@langchain_core_prompts.js.map

{
  "version": 3,
  "sources": ["../../@langchain/core/src/prompts/base.ts", "../../@langchain/core/src/prompt_values.ts", "../../@langchain/core/src/prompts/string.ts", "../../mustache/mustache.mjs", "../../@langchain/core/src/prompts/template.ts", "../../@langchain/core/src/prompts/prompt.ts", "../../@langchain/core/src/prompts/image.ts", "../../@langchain/core/src/prompts/dict.ts", "../../@langchain/core/src/prompts/chat.ts", "../../@langchain/core/src/prompts/few_shot.ts", "../../@langchain/core/src/prompts/pipeline.ts", "../../@langchain/core/src/prompts/structured.ts", "../../@langchain/core/dist/prompts/index.js"],
  "sourcesContent": ["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type {\n  InputValues,\n  PartialValues,\n  StringWithAutocomplete,\n} from \"../utils/types/index.js\";\nimport { type BasePromptValueInterface } from \"../prompt_values.js\";\nimport { BaseOutputParser } from \"../output_parsers/index.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseCallbackConfig } from \"../callbacks/manager.js\";\n\nexport type TypedPromptInputValues<RunInput> = InputValues<\n  StringWithAutocomplete<Extract<keyof RunInput, string>>\n>;\n\nexport type Example = Record<string, string>;\n\n/**\n * Input common to all prompt templates.\n */\nexport interface BasePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  InputVariables extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> {\n  /**\n   * A list of variable names the prompt template expects\n   */\n  inputVariables: Array<Extract<keyof InputVariables, string>>;\n\n  /**\n   * How to parse the output of calling an LLM on this formatted prompt\n   */\n  outputParser?: BaseOutputParser;\n\n  /** Partial variables */\n  partialVariables?: PartialValues<PartialVariableName>;\n}\n\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport abstract class BasePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    RunOutput extends BasePromptValueInterface = BasePromptValueInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements BasePromptTemplateInput\n{\n  declare PromptValueReturnType: RunOutput;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"prompts\", this._getPromptType()];\n\n  get lc_attributes(): SerializedFields | undefined {\n    return {\n      partialVariables: undefined, // python doesn't support this yet\n    };\n  }\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  outputParser?: BaseOutputParser;\n\n  partialVariables: PartialValues<PartialVariableName>;\n\n  /**\n   * Metadata to be used for tracing.\n   */\n  metadata?: Record<string, unknown>;\n\n  /** Tags to be used for tracing. */\n  tags?: string[];\n\n  constructor(input: BasePromptTemplateInput) {\n    super(input);\n    const { inputVariables } = input;\n    if (inputVariables.includes(\"stop\")) {\n      throw new Error(\n        \"Cannot have an input variable named 'stop', as it is used internally, please rename.\"\n      );\n    }\n    Object.assign(this, input);\n  }\n\n  abstract partial(\n    values: PartialValues\n  ): Promise<BasePromptTemplate<RunInput, RunOutput, PartialVariableName>>;\n\n  /**\n   * Merges partial variables and user variables.\n   * @param userVariables The user variables to merge with the partial variables.\n   * @returns A Promise that resolves to an object containing the merged variables.\n   */\n  async mergePartialAndUserVariables(\n    userVariables: TypedPromptInputValues<RunInput>\n  ): Promise<\n    InputValues<Extract<keyof RunInput, string> | PartialVariableName>\n  > {\n    const partialVariables = this.partialVariables ?? {};\n    const partialValues: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(partialVariables)) {\n      if (typeof value === \"string\") {\n        partialValues[key] = value;\n      } else {\n        partialValues[key] = await (value as () => Promise<string>)();\n      }\n    }\n\n    const allKwargs = {\n      ...(partialValues as Record<PartialVariableName, string>),\n      ...userVariables,\n    };\n    return allKwargs;\n  }\n\n  /**\n   * Invokes the prompt template with the given input and options.\n   * @param input The input to invoke the prompt template with.\n   * @param options Optional configuration for the callback.\n   * @returns A Promise that resolves to the output of the prompt template.\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    const metadata = {\n      ...this.metadata,\n      ...options?.metadata,\n    };\n    const tags = [...(this.tags ?? []), ...(options?.tags ?? [])];\n    return this._callWithConfig(\n      (input: RunInput) => this.formatPromptValue(input),\n      input,\n      { ...options, tags, metadata, runType: \"prompt\" }\n    );\n  }\n\n  /**\n   * Format the prompt given the input values.\n   *\n   * @param values - A dictionary of arguments to be passed to the prompt template.\n   * @returns A formatted prompt string.\n   *\n   * @example\n   * ```ts\n   * prompt.format({ foo: \"bar\" });\n   * ```\n   */\n  abstract format(values: TypedPromptInputValues<RunInput>): Promise<string>;\n\n  /**\n   * Format the prompt given the input values and return a formatted prompt value.\n   * @param values\n   * @returns A formatted PromptValue.\n   */\n  abstract formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Return the string type key uniquely identifying this class of prompt template.\n   */\n  abstract _getPromptType(): string;\n}\n", "import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type { InputValues } from \"../utils/types/index.js\";\nimport {\n  type StringPromptValueInterface,\n  StringPromptValue,\n} from \"../prompt_values.js\";\nimport { BasePromptTemplate, type TypedPromptInputValues } from \"./base.js\";\n\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport abstract class BaseStringPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplate<\n  RunInput,\n  StringPromptValueInterface,\n  PartialVariableName\n> {\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<StringPromptValueInterface> {\n    const formattedPrompt = await this.format(values);\n    return new StringPromptValue(formattedPrompt);\n  }\n}\n", "/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\n  return objectToString.call(object) === '[object Array]';\n};\n\nfunction isFunction (object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr (obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\n\nfunction escapeRegExp (string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty (obj, propName) {\n  return obj != null && typeof obj === 'object' && (propName in obj);\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty (primitive, propName) {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasOwnProperty\n    && primitive.hasOwnProperty(propName)\n  );\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp (re, string) {\n  return regExpTest.call(re, string);\n}\n\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace (string) {\n  return !testRegExp(nonSpaceRe, string);\n}\n\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nfunction escapeHtml (string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n    return entityMap[s];\n  });\n}\n\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate (template, tags) {\n  if (!template)\n    return [];\n  var lineHasNonSpace = false;\n  var sections = [];     // Stack to hold section tokens\n  var tokens = [];       // Buffer to hold the tokens\n  var spaces = [];       // Indices of whitespace tokens on the current line\n  var hasTag = false;    // Is there a {{tag}} on the current line?\n  var nonSpace = false;  // Is there a non-space char on the current line?\n  var indentation = '';  // Tracks indentation for tags that use it\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace () {\n    if (hasTag && !nonSpace) {\n      while (spaces.length)\n        delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n\n    hasTag = false;\n    nonSpace = false;\n  }\n\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags (tagsToCompile) {\n    if (typeof tagsToCompile === 'string')\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n      throw new Error('Invalid tags: ' + tagsToCompile);\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n\n  compileTags(tags || mustache.tags);\n\n  var scanner = new Scanner(template);\n\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n\n        tokens.push([ 'text', chr, start, start + 1 ]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe))\n      break;\n\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe))\n      throw new Error('Unclosed tag at ' + scanner.pos);\n\n    if (type == '>') {\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n    } else {\n      token = [ type, value, start, scanner.pos ];\n    }\n    tagIndex++;\n    tokens.push(token);\n\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n\n      if (!openSection)\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n      if (openSection[1] !== value)\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n\n  if (openSection)\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens (tokens) {\n  var squashedTokens = [];\n\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens (tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner (string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos () {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan (re) {\n  var match = this.tail.match(re);\n\n  if (!match || match.index !== 0)\n    return '';\n\n  var string = match[0];\n\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil (re) {\n  var index = this.tail.search(re), match;\n\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n\n  this.pos += match.length;\n\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context (view, parentContext) {\n  this.view = view;\n  this.cache = { '.': this.view };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push (view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup (name) {\n  var cache = this.cache;\n\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this, intermediateValue, names, index, lookupHit = false;\n\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1)\n            lookupHit = (\n              hasProperty(intermediateValue, names[index])\n              || primitiveHasOwnProperty(intermediateValue, names[index])\n            );\n\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n\n      context = context.parent;\n    }\n\n    cache[name] = value;\n  }\n\n  if (isFunction(value))\n    value = value.call(this.view);\n\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer () {\n  this.templateCache = {\n    _cache: {},\n    set: function set (key, value) {\n      this._cache[key] = value;\n    },\n    get: function get (key) {\n      return this._cache[key];\n    },\n    clear: function clear () {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache () {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse (template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render (template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n    else if (symbol === '&') value = this.unescapedValue(token, context);\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\n    else if (symbol === 'text') value = this.rawValue(token);\n\n    if (value !== undefined)\n      buffer += value;\n  }\n\n  return buffer;\n};\n\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender (template) {\n    return self.render(template, context, partials, config);\n  }\n\n  if (!value) return;\n\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string')\n      throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n    if (value != null)\n      buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\n\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || (isArray(value) && value.length === 0))\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\n\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\n\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\n\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return value;\n};\n\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n};\n\nWriter.prototype.rawValue = function rawValue (token) {\n  return token[1];\n};\n\nWriter.prototype.getConfigTags = function getConfigTags (config) {\n  if (isArray(config)) {\n    return config;\n  }\n  else if (config && typeof config === 'object') {\n    return config.tags;\n  }\n  else {\n    return undefined;\n  }\n};\n\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  }\n  else {\n    return undefined;\n  }\n};\n\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: [ '{{', '}}' ],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache (cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache () {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache () {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse (template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render (template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\n                        'argument for mustache#render(template, view, partials)');\n  }\n\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n\nexport default mustache;\n", "import mustache from \"mustache\";\nimport { MessageContent } from \"../messages/index.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = (text) => text;\n}\n\n/**\n * Type that specifies the format of a template.\n */\nexport type TemplateFormat = \"f-string\" | \"mustache\";\n\n/**\n * Type that represents a node in a parsed format string. It can be either\n * a literal text or a variable name.\n */\nexport type ParsedTemplateNode =\n  | { type: \"literal\"; text: string }\n  | { type: \"variable\"; name: string };\n\n/**\n * Alias for `ParsedTemplateNode` since it is the same for\n * both f-string and mustache templates.\n */\nexport type ParsedFStringNode = ParsedTemplateNode;\n\nexport const parseFString = (template: string): ParsedTemplateNode[] => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes: ParsedTemplateNode[] = [];\n\n  const nextBracket = (bracket: \"}\" | \"{\" | \"{}\", start: number) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({ type: \"literal\", text: \"{\" });\n      i += 2;\n    } else if (\n      chars[i] === \"}\" &&\n      i + 1 < chars.length &&\n      chars[i + 1] === \"}\"\n    ) {\n      nodes.push({ type: \"literal\", text: \"}\" });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\"),\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({ type: \"literal\", text });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @param {string[]} context Array of section variable names for nested context\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (\n  template: mustache.TemplateSpans,\n  context: string[] = []\n): ParsedTemplateNode[] => {\n  const nodes: ParsedTemplateNode[] = [];\n\n  for (const temp of template) {\n    if (temp[0] === \"name\") {\n      const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n      nodes.push({ type: \"variable\", name });\n    } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n      // # represents a section, \"&\" represents an unescaped variable.\n      // These should both be considered variables.\n      nodes.push({ type: \"variable\", name: temp[1] });\n\n      // If this is a section with nested content, recursively process it\n      if (temp[0] === \"#\" && temp.length > 4 && Array.isArray(temp[4])) {\n        const newContext = [...context, temp[1]];\n        const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);\n        nodes.push(...nestedNodes);\n      }\n    } else {\n      nodes.push({ type: \"literal\", text: temp[1] });\n    }\n  }\n\n  return nodes;\n};\n\nexport const parseMustache = (template: string) => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\n\nexport const interpolateFString = (template: string, values: InputValues) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue =\n          typeof values[node.name] === \"string\"\n            ? values[node.name]\n            : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n\n    return res + node.text;\n  }, \"\");\n};\n\nexport const interpolateMustache = (template: string, values: InputValues) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\n\n/**\n * Type that represents a function that takes a template string and a set\n * of input values, and returns a string where all variables in the\n * template have been replaced with their corresponding values.\n */\ntype Interpolator = (template: string, values: InputValues) => string;\n\n/**\n * Type that represents a function that takes a template string and\n * returns an array of `ParsedTemplateNode`.\n */\ntype Parser = (template: string) => ParsedTemplateNode[];\n\nexport const DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator> = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache,\n};\n\nexport const DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser> = {\n  \"f-string\": parseFString,\n  mustache: parseMustache,\n};\n\nexport const renderTemplate = (\n  template: string,\n  templateFormat: TemplateFormat,\n  inputValues: InputValues\n) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\n\nexport const parseTemplate = (\n  template: string,\n  templateFormat: TemplateFormat\n) => DEFAULT_PARSER_MAPPING[templateFormat](template);\n\nexport const checkValidTemplate = (\n  template: MessageContent,\n  templateFormat: TemplateFormat,\n  inputVariables: string[]\n) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    const dummyInputs: InputValues = inputVariables.reduce((acc, v) => {\n      acc[v] = \"foo\";\n      return acc;\n    }, {} as Record<string, string>);\n    if (Array.isArray(template)) {\n      template.forEach((message) => {\n        if (\n          message.type === \"text\" &&\n          \"text\" in message &&\n          typeof message.text === \"string\"\n        ) {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else if (\n            typeof message.image_url === \"object\" &&\n            message.image_url !== null &&\n            \"url\" in message.image_url &&\n            typeof message.image_url.url === \"string\"\n          ) {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(\n            `Invalid message template received. ${JSON.stringify(\n              message,\n              null,\n              2\n            )}`\n          );\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  checkValidTemplate,\n  parseTemplate,\n  renderTemplate,\n  type TemplateFormat,\n} from \"./template.js\";\nimport type { SerializedPromptTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { MessageContent, ContentBlock } from \"../messages/index.js\";\n\n/**\n * Inputs to create a {@link PromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface PromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n  Format extends TemplateFormat = TemplateFormat\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: MessageContent;\n\n  /**\n   * The format of the prompt template. Options are \"f-string\" and \"mustache\"\n   */\n  templateFormat?: Format;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\ntype NonAlphanumeric =\n  | \" \"\n  | \"\\t\"\n  | \"\\n\"\n  | \"\\r\"\n  | '\"'\n  | \"'\"\n  | \"{\"\n  | \"[\"\n  | \"(\"\n  | \"`\"\n  | \":\"\n  | \";\";\n\n/**\n * Recursive type to extract template parameters from a string.\n * @template T - The input string.\n * @template Result - The resulting array of extracted template parameters.\n */\ntype ExtractTemplateParamsRecursive<\n  T extends string,\n  Result extends string[] = []\n> = T extends `${string}{${infer Param}}${infer Rest}`\n  ? Param extends `${NonAlphanumeric}${string}`\n    ? ExtractTemplateParamsRecursive<Rest, Result> // for non-template variables that look like template variables e.g. see https://github.com/langchain-ai/langchainjs/blob/main/langchain/src/chains/query_constructor/prompt.ts\n    : ExtractTemplateParamsRecursive<Rest, [...Result, Param]>\n  : Result;\n\nexport type ParamsFromFString<T extends string> = {\n  [Key in\n    | ExtractTemplateParamsRecursive<T>[number]\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (string & Record<never, never>)]: any;\n};\n\nexport type ExtractedFStringParams<\n  T extends string,\n  RunInput extends InputValues = Symbol\n> = RunInput extends Symbol ? ParamsFromFString<T> : RunInput;\n\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseStringPromptTemplate<RunInput, PartialVariableName>\n  implements PromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"PromptTemplate\";\n  }\n\n  template: MessageContent;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: PromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      if (this.templateFormat === \"mustache\") {\n        throw new Error(\"Mustache templates cannot be validated.\");\n      }\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.template,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(\n      this.template as string,\n      this.templateFormat,\n      allValues\n    );\n  }\n\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intended to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(\n    examples: string[],\n    suffix: string,\n    inputVariables: string[],\n    exampleSeparator = \"\\n\\n\",\n    prefix = \"\"\n  ) {\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template,\n    });\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const { templateFormat = \"f-string\", ...rest } = options ?? {};\n    const names = new Set<string>();\n    parseTemplate(template, templateFormat).forEach((node) => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n\n    return new PromptTemplate({\n      // Rely on extracted types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputVariables: [...names] as any[],\n      templateFormat,\n      template,\n      ...rest,\n    });\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of PromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new PromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  serialize(): SerializedPromptTemplate {\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Cannot serialize a prompt template with an output parser\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedPromptTemplate\n  ): Promise<PromptTemplate> {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format,\n    });\n    return res;\n  }\n\n  // TODO(from file)\n}\n", "import { MessageContent, ContentBlock } from \"../messages/index.js\";\nimport { ImagePromptValue, ImageContent } from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport {\n  BasePromptTemplate,\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\n\n/**\n * Inputs to create a {@link ImagePromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface ImagePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: Record<string, unknown>;\n\n  /**\n   * The format of the prompt template. Options are 'f-string'\n   *\n   * @defaultValue 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\n/**\n * An image prompt template for a multimodal model.\n */\nexport class ImagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplate<RunInput, ImagePromptValue, PartialVariableName> {\n  static lc_name() {\n    return \"ImagePromptTemplate\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"image\"];\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: ImagePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.template = input.template;\n    this.templateFormat = input.templateFormat ?? this.templateFormat;\n    this.validateTemplate = input.validateTemplate ?? this.validateTemplate;\n    this.additionalContentFields = input.additionalContentFields;\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        [\n          { type: \"image_url\", image_url: this.template },\n        ] as unknown as MessageContent,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of ImagePromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ImagePromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format<FormatOutput = ImageContent>(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<FormatOutput> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const formatted: Record<string, any> = {};\n    for (const [key, value] of Object.entries(this.template)) {\n      if (typeof value === \"string\") {\n        formatted[key] = renderTemplate(value, this.templateFormat, values);\n      } else {\n        formatted[key] = value;\n      }\n    }\n    const url = values.url || formatted.url;\n    const detail = values.detail || formatted.detail;\n    if (!url) {\n      throw new Error(\"Must provide either an image URL.\");\n    }\n    if (typeof url !== \"string\") {\n      throw new Error(\"url must be a string.\");\n    }\n    const output: ImageContent = { url };\n    if (detail) {\n      output.detail = detail;\n    }\n    return output as FormatOutput;\n  }\n\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ImagePromptValue> {\n    const formattedPrompt = await this.format(values);\n    return new ImagePromptValue(formattedPrompt);\n  }\n}\n", "import { Runnable } from \"../runnables/base.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { TypedPromptInputValues } from \"./base.js\";\nimport { parseTemplate, renderTemplate, TemplateFormat } from \"./template.js\";\n\nexport class DictPromptTemplate<\n  RunInput extends InputValues = InputValues,\n  RunOutput extends Record<string, unknown> = Record<string, unknown>\n> extends Runnable<TypedPromptInputValues<RunInput>, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"dict\"];\n\n  lc_serializable = true;\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat;\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  static lc_name() {\n    return \"DictPromptTemplate\";\n  }\n\n  constructor(fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }) {\n    const templateFormat = fields.templateFormat ?? \"f-string\";\n    const inputVariables = _getInputVariables(\n      fields.template,\n      templateFormat\n    ) as Array<Extract<keyof RunInput, string>>;\n    super({ inputVariables, ...fields });\n    this.template = fields.template;\n    this.templateFormat = templateFormat;\n    this.inputVariables = inputVariables;\n  }\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<RunOutput> {\n    return _insertInputVariables(\n      this.template,\n      values,\n      this.templateFormat\n    ) as RunOutput;\n  }\n\n  async invoke(\n    values: TypedPromptInputValues<InputValues>\n  ): Promise<RunOutput> {\n    return await this._callWithConfig(this.format.bind(this), values, {\n      runType: \"prompt\",\n    });\n  }\n}\n\nfunction _getInputVariables(\n  template: Record<string, unknown>,\n  templateFormat: TemplateFormat\n): Array<Extract<keyof InputValues, string>> {\n  const inputVariables: Array<Extract<keyof InputValues, string>> = [];\n  for (const v of Object.values(template)) {\n    if (typeof v === \"string\") {\n      parseTemplate(v, templateFormat).forEach((t) => {\n        if (t.type === \"variable\") {\n          inputVariables.push(t.name);\n        }\n      });\n    } else if (Array.isArray(v)) {\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          parseTemplate(x, templateFormat).forEach((t) => {\n            if (t.type === \"variable\") {\n              inputVariables.push(t.name);\n            }\n          });\n        } else if (typeof x === \"object\") {\n          inputVariables.push(..._getInputVariables(x, templateFormat));\n        }\n      }\n    } else if (typeof v === \"object\" && v !== null) {\n      inputVariables.push(\n        ..._getInputVariables(v as Record<string, unknown>, templateFormat)\n      );\n    }\n  }\n  return Array.from(new Set(inputVariables));\n}\n\nfunction _insertInputVariables(\n  template: Record<string, unknown>,\n  inputs: TypedPromptInputValues<InputValues>,\n  templateFormat: TemplateFormat\n): Record<string, unknown> {\n  const formatted: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(template)) {\n    if (typeof v === \"string\") {\n      formatted[k] = renderTemplate(v, templateFormat, inputs);\n    } else if (Array.isArray(v)) {\n      const formattedV: Array<unknown> = [];\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          formattedV.push(renderTemplate(x, templateFormat, inputs));\n        } else if (typeof x === \"object\") {\n          formattedV.push(_insertInputVariables(x, inputs, templateFormat));\n        }\n      }\n      formatted[k] = formattedV;\n    } else if (typeof v === \"object\" && v !== null) {\n      formatted[k] = _insertInputVariables(\n        v as Record<string, unknown>,\n        inputs,\n        templateFormat\n      );\n    } else {\n      formatted[k] = v;\n    }\n  }\n  return formatted;\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  AIMessage,\n  HumanMessage,\n  SystemMessage,\n  BaseMessage,\n  ChatMessage,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  isBaseMessage,\n  MessageContent,\n  ContentBlock,\n} from \"../messages/index.js\";\nimport {\n  type ChatPromptValueInterface,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport {\n  BasePromptTemplate,\n  type BasePromptTemplateInput,\n  type TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  PromptTemplate,\n  type ParamsFromFString,\n  PromptTemplateInput,\n  ExtractedFStringParams,\n} from \"./prompt.js\";\nimport { ImagePromptTemplate } from \"./image.js\";\nimport {\n  ParsedTemplateNode,\n  TemplateFormat,\n  parseFString,\n  parseMustache,\n} from \"./template.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nimport { DictPromptTemplate } from \"./dict.js\";\n\n/**\n * Abstract class that serves as a base for creating message prompt\n * templates. It defines how to format messages for different roles in a\n * conversation.\n */\nexport abstract class BaseMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[]\n> extends Runnable<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  abstract inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  /**\n   * Method that takes an object of TypedPromptInputValues and returns a\n   * promise that resolves to an array of BaseMessage instances.\n   * @param values Object of TypedPromptInputValues\n   * @returns Formatted array of BaseMessages\n   */\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Calls the formatMessages method with the provided input and options.\n   * @param input Input for the formatMessages method\n   * @param options Optional BaseCallbackConfig\n   * @returns Formatted output messages\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    return this._callWithConfig(\n      (input: RunInput) => this.formatMessages(input),\n      input,\n      { ...options, runType: \"prompt\" }\n    );\n  }\n}\n\n/**\n * Interface for the fields of a MessagePlaceholder.\n */\nexport interface MessagesPlaceholderFields<T extends string> {\n  variableName: T;\n  optional?: boolean;\n}\n\n/**\n * Class that represents a placeholder for messages in a chat prompt. It\n * extends the BaseMessagePromptTemplate.\n */\nexport class MessagesPlaceholder<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any\n  >\n  extends BaseMessagePromptTemplate<RunInput>\n  implements MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n{\n  static lc_name() {\n    return \"MessagesPlaceholder\";\n  }\n\n  variableName: Extract<keyof RunInput, string>;\n\n  optional: boolean;\n\n  constructor(variableName: Extract<keyof RunInput, string>);\n\n  constructor(\n    fields: MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  );\n\n  constructor(\n    fields:\n      | Extract<keyof RunInput, string>\n      | MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  ) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = { variableName: fields };\n    }\n    super(fields);\n    this.variableName = fields.variableName;\n    this.optional = fields.optional ?? false;\n  }\n\n  get inputVariables() {\n    return [this.variableName];\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const input = values[this.variableName];\n    if (this.optional && !input) {\n      return [];\n    } else if (!input) {\n      const error = new Error(\n        `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`\n      );\n      error.name = \"InputFormatError\";\n      throw error;\n    }\n\n    let formattedMessages;\n    try {\n      if (Array.isArray(input)) {\n        formattedMessages = input.map(coerceMessageLikeToMessage);\n      } else {\n        formattedMessages = [coerceMessageLikeToMessage(input)];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      const readableInput =\n        typeof input === \"string\" ? input : JSON.stringify(input, null, 2);\n      const error = new Error(\n        [\n          `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,\n          `Received value: ${readableInput}`,\n          `Additional message: ${e.message}`,\n        ].join(\"\\n\\n\")\n      );\n      error.name = \"InputFormatError\";\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).lc_error_code = e.lc_error_code;\n      throw error;\n    }\n\n    return formattedMessages;\n  }\n}\n\n/**\n * Interface for the fields of a MessageStringPromptTemplate.\n */\nexport interface MessageStringPromptTemplateFields<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends InputValues = any\n> {\n  prompt: BaseStringPromptTemplate<T, string>;\n}\n\n/**\n * Abstract class that serves as a base for creating message string prompt\n * templates. It extends the BaseMessagePromptTemplate.\n */\nexport abstract class BaseMessageStringPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends BaseMessagePromptTemplate<RunInput> {\n  prompt: BaseStringPromptTemplate<\n    InputValues<Extract<keyof RunInput, string>>,\n    string\n  >;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields: MessageStringPromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | MessageStringPromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<\n          InputValues<Extract<keyof RunInput, string>>,\n          string\n        >\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n  }\n\n  get inputVariables() {\n    return this.prompt.inputVariables;\n  }\n\n  abstract format(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage>;\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    return [await this.format(values)];\n  }\n}\n\n/**\n * Abstract class that serves as a base for creating chat prompt\n * templates. It extends the BasePromptTemplate.\n */\nexport abstract class BaseChatPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplate<\n  RunInput,\n  ChatPromptValueInterface,\n  PartialVariableName\n> {\n  constructor(input: BasePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n  }\n\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]>;\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    return (await this.formatPromptValue(values)).toString();\n  }\n\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ChatPromptValueInterface> {\n    const resultMessages = await this.formatMessages(values);\n    return new ChatPromptValue(resultMessages);\n  }\n}\n\n/**\n * Interface for the fields of a ChatMessagePromptTemplate.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface ChatMessagePromptTemplateFields<T extends InputValues = any>\n  extends MessageStringPromptTemplateFields<T> {\n  role: string;\n}\n\n/**\n * Class that represents a chat message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class ChatMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends BaseMessageStringPromptTemplate<RunInput> {\n  static lc_name() {\n    return \"ChatMessagePromptTemplate\";\n  }\n\n  role: string;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >,\n    role: string\n  );\n\n  constructor(\n    fields: ChatMessagePromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | ChatMessagePromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<InputValues<Extract<keyof RunInput, string>>>,\n    role?: string\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  async format(values: RunInput): Promise<BaseMessage> {\n    return new ChatMessage(await this.prompt.format(values), this.role);\n  }\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(template: T, role: string, options?: { templateFormat?: TemplateFormat }) {\n    return new this(\n      PromptTemplate.fromTemplate<RunInput, T>(template, {\n        templateFormat: options?.templateFormat,\n      }),\n      role\n    );\n  }\n}\n\ninterface _TextTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: string | Record<string, any>;\n}\n\nfunction isTextTemplateParam(param: unknown): param is _TextTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    Object.keys(param).length === 1 &&\n    \"text\" in param &&\n    typeof param.text === \"string\"\n  );\n}\n\ninterface _ImageTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  image_url?: string | Record<string, any>;\n}\n\nfunction isImageTemplateParam(param: unknown): param is _ImageTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    \"image_url\" in param &&\n    (typeof param.image_url === \"string\" ||\n      (typeof param.image_url === \"object\" &&\n        param.image_url !== null &&\n        \"url\" in param.image_url &&\n        typeof param.image_url.url === \"string\"))\n  );\n}\n\ntype MessageClass =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage;\n\ntype ChatMessageClass = typeof ChatMessage;\n\ninterface _StringImageMessagePromptTemplateOptions<\n  Format extends TemplateFormat = TemplateFormat\n> extends Record<string, unknown> {\n  templateFormat?: Format;\n}\n\nclass _StringImageMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[]\n> extends BaseMessagePromptTemplate<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  inputVariables: Array<Extract<keyof RunInput, string>> = [];\n\n  additionalOptions: _StringImageMessagePromptTemplateOptions = {};\n\n  prompt:\n    | BaseStringPromptTemplate<\n        InputValues<Extract<keyof RunInput, string>>,\n        string\n      >\n    | Array<\n        | BaseStringPromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | ImagePromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | MessageStringPromptTemplateFields<\n            InputValues<Extract<keyof RunInput, string>>\n          >\n        | DictPromptTemplate<InputValues<Extract<keyof RunInput, string>>>\n      >;\n\n  protected messageClass?: MessageClass;\n\n  static _messageClass(): MessageClass {\n    throw new Error(\n      \"Can not invoke _messageClass from inside _StringImageMessagePromptTemplate\"\n    );\n  }\n\n  // ChatMessage contains role field, others don't.\n  // Because of this, we have a separate class property for ChatMessage.\n  protected chatMessageClass?: ChatMessageClass;\n\n  constructor(\n    /** @TODO When we come up with a better way to type prompt templates, fix this */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    fields: any,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n    if (Array.isArray(this.prompt)) {\n      let inputVariables: Extract<keyof RunInput, string>[] = [];\n      this.prompt.forEach((prompt) => {\n        if (\"inputVariables\" in prompt) {\n          inputVariables = inputVariables.concat(prompt.inputVariables);\n        }\n      });\n      this.inputVariables = inputVariables;\n    } else {\n      this.inputVariables = this.prompt.inputVariables;\n    }\n    this.additionalOptions = additionalOptions ?? this.additionalOptions;\n  }\n\n  createMessage(content: MessageContent) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const constructor = this.constructor as any;\n    if (constructor._messageClass()) {\n      const MsgClass = constructor._messageClass();\n      return new MsgClass({ content });\n    } else if (constructor.chatMessageClass) {\n      const MsgClass = constructor.chatMessageClass();\n      // Assuming ChatMessage constructor also takes a content argument\n      return new MsgClass({\n        content,\n        role: this.getRoleFromMessageClass(MsgClass.lc_name()),\n      });\n    } else {\n      throw new Error(\"No message class defined\");\n    }\n  }\n\n  getRoleFromMessageClass(name: string) {\n    switch (name) {\n      case \"HumanMessage\":\n        return \"human\";\n      case \"AIMessage\":\n        return \"ai\";\n      case \"SystemMessage\":\n        return \"system\";\n      case \"ChatMessage\":\n        return \"chat\";\n      default:\n        throw new Error(\"Invalid message class name\");\n    }\n  }\n\n  static fromTemplate(\n    template:\n      | string\n      | Array<\n          | string\n          | _TextTemplateParam\n          | _ImageTemplateParam\n          | Record<string, unknown>\n        >,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (typeof template === \"string\") {\n      return new this(PromptTemplate.fromTemplate(template, additionalOptions));\n    }\n    const prompt: Array<\n      | PromptTemplate<InputValues>\n      | ImagePromptTemplate<InputValues>\n      | DictPromptTemplate\n    > = [];\n    for (const item of template) {\n      // handle string cases\n      if (typeof item === \"string\") {\n        prompt.push(PromptTemplate.fromTemplate(item, additionalOptions));\n      } else if (item === null) {\n        // pass\n      } else if (isTextTemplateParam(item)) {\n        let text = \"\";\n        if (typeof item.text === \"string\") {\n          text = item.text ?? \"\";\n        }\n\n        const options = {\n          ...additionalOptions,\n          additionalContentFields: item as ContentBlock,\n        };\n        prompt.push(PromptTemplate.fromTemplate(text, options));\n      } else if (isImageTemplateParam(item)) {\n        let imgTemplate = item.image_url ?? \"\";\n        let imgTemplateObject: ImagePromptTemplate<InputValues>;\n        let inputVariables: string[] = [];\n        if (typeof imgTemplate === \"string\") {\n          let parsedTemplate: ParsedTemplateNode[];\n          if (additionalOptions?.templateFormat === \"mustache\") {\n            parsedTemplate = parseMustache(imgTemplate);\n          } else {\n            parsedTemplate = parseFString(imgTemplate);\n          }\n\n          const variables = parsedTemplate.flatMap((item) =>\n            item.type === \"variable\" ? [item.name] : []\n          );\n\n          if ((variables?.length ?? 0) > 0) {\n            if (variables.length > 1) {\n              throw new Error(\n                `Only one format variable allowed per image template.\\nGot: ${variables}\\nFrom: ${imgTemplate}`\n              );\n            }\n            inputVariables = [variables[0]];\n          } else {\n            inputVariables = [];\n          }\n\n          imgTemplate = { url: imgTemplate };\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else if (typeof imgTemplate === \"object\") {\n          if (\"url\" in imgTemplate) {\n            let parsedTemplate: ParsedTemplateNode[];\n            if (additionalOptions?.templateFormat === \"mustache\") {\n              parsedTemplate = parseMustache(imgTemplate.url);\n            } else {\n              parsedTemplate = parseFString(imgTemplate.url);\n            }\n\n            inputVariables = parsedTemplate.flatMap((item) =>\n              item.type === \"variable\" ? [item.name] : []\n            );\n          } else {\n            inputVariables = [];\n          }\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else {\n          throw new Error(\"Invalid image template\");\n        }\n        prompt.push(imgTemplateObject);\n      } else if (typeof item === \"object\") {\n        prompt.push(\n          new DictPromptTemplate({\n            template: item,\n            templateFormat: additionalOptions?.templateFormat,\n          })\n        );\n      }\n    }\n    return new this({ prompt, additionalOptions });\n  }\n\n  async format(input: TypedPromptInputValues<RunInput>): Promise<BaseMessage> {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (this.prompt instanceof BaseStringPromptTemplate) {\n      const text = await this.prompt.format(input);\n\n      return this.createMessage(text);\n    } else {\n      const content: MessageContent = [];\n      for (const prompt of this.prompt) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let inputs: Record<string, any> = {};\n        if (!(\"inputVariables\" in prompt)) {\n          throw new Error(\n            `Prompt ${prompt} does not have inputVariables defined.`\n          );\n        }\n        for (const item of prompt.inputVariables) {\n          if (!inputs) {\n            inputs = { [item]: input[item] };\n          }\n          inputs = { ...inputs, [item]: input[item] };\n        }\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (prompt instanceof BaseStringPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          if (formatted !== \"\") {\n            content.push({\n              ...additionalContentFields,\n              type: \"text\",\n              text: formatted,\n            });\n          }\n          /** @TODO replace this */\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof ImagePromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            type: \"image_url\",\n            image_url: formatted,\n          });\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof DictPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            ...formatted,\n          } as ContentBlock);\n        }\n      }\n      return this.createMessage(content);\n    }\n  }\n\n  async formatMessages(values: RunInput): Promise<RunOutput> {\n    return [await this.format(values)] as BaseMessage[] as RunOutput;\n  }\n}\n\n/**\n * Class that represents a human message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = HumanMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class HumanMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof HumanMessage {\n    return HumanMessage;\n  }\n\n  static lc_name() {\n    return \"HumanMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents an AI message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class AIMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof AIMessage {\n    return AIMessage;\n  }\n\n  static lc_name() {\n    return \"AIMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents a system message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class SystemMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof SystemMessage {\n    return SystemMessage;\n  }\n\n  static lc_name() {\n    return \"SystemMessagePromptTemplate\";\n  }\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface ChatPromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt messages\n   */\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  /**\n   * Whether to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * The formatting method to use on the prompt.\n   * @default \"f-string\"\n   */\n  templateFormat?: TemplateFormat;\n}\n\nexport type BaseMessagePromptTemplateLike =\n  | BaseMessagePromptTemplate\n  | BaseMessageLike;\n\nfunction _isBaseMessagePromptTemplate(\n  baseMessagePromptTemplateLike: BaseMessagePromptTemplateLike\n): baseMessagePromptTemplateLike is BaseMessagePromptTemplate {\n  return (\n    typeof (baseMessagePromptTemplateLike as BaseMessagePromptTemplate)\n      .formatMessages === \"function\"\n  );\n}\n\nfunction _coerceMessagePromptTemplateLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  Extra extends Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  > = Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  >\n>(\n  messagePromptTemplateLike: BaseMessagePromptTemplateLike,\n  extra?: Extra\n): BaseMessagePromptTemplate | BaseMessage {\n  if (\n    _isBaseMessagePromptTemplate(messagePromptTemplateLike) ||\n    isBaseMessage(messagePromptTemplateLike)\n  ) {\n    return messagePromptTemplateLike;\n  }\n  if (\n    Array.isArray(messagePromptTemplateLike) &&\n    messagePromptTemplateLike[0] === \"placeholder\"\n  ) {\n    const messageContent = messagePromptTemplateLike[1];\n    if (\n      extra?.templateFormat === \"mustache\" &&\n      typeof messageContent === \"string\" &&\n      messageContent.slice(0, 2) === \"{{\" &&\n      messageContent.slice(-2) === \"}}\"\n    ) {\n      const variableName = messageContent.slice(2, -2);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    } else if (\n      typeof messageContent === \"string\" &&\n      messageContent[0] === \"{\" &&\n      messageContent[messageContent.length - 1] === \"}\"\n    ) {\n      const variableName = messageContent.slice(1, -1);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    }\n    throw new Error(\n      `Invalid placeholder template for format ${\n        extra?.templateFormat ?? `\"f-string\"`\n      }: \"${\n        messagePromptTemplateLike[1]\n      }\". Expected a variable name surrounded by ${\n        extra?.templateFormat === \"mustache\" ? \"double\" : \"single\"\n      } curly braces.`\n    );\n  }\n  const message = coerceMessageLikeToMessage(messagePromptTemplateLike);\n  let templateData:\n    | string\n    | (\n        | string\n        | _TextTemplateParam\n        | _ImageTemplateParam\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | Record<string, any>\n      )[];\n\n  if (typeof message.content === \"string\") {\n    templateData = message.content;\n  } else {\n    // Assuming message.content is an array of complex objects, transform it.\n    templateData = message.content.map((item) => {\n      if (\"text\" in item) {\n        return { ...item, text: item.text };\n      } else if (\"image_url\" in item) {\n        return { ...item, image_url: item.image_url };\n      } else {\n        return item;\n      }\n    });\n  }\n\n  if (message._getType() === \"human\") {\n    return HumanMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"ai\") {\n    return AIMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"system\") {\n    return SystemMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (ChatMessage.isInstance(message)) {\n    return ChatMessagePromptTemplate.fromTemplate(\n      message.content as string,\n      message.role,\n      extra\n    );\n  } else {\n    throw new Error(\n      `Could not coerce message prompt template from input. Received message type: \"${message._getType()}\".`\n    );\n  }\n}\n\nfunction isMessagesPlaceholder(\n  x: BaseMessagePromptTemplate | BaseMessage\n): x is MessagesPlaceholder {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (x.constructor as any).lc_name() === \"MessagesPlaceholder\";\n}\n\n/**\n * Class that represents a chat prompt. It extends the\n * BaseChatPromptTemplate and uses an array of BaseMessagePromptTemplate\n * instances to format a series of messages for a conversation.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const chatPrompt = ChatPromptTemplate.fromMessages([\n *   [\"ai\", \"You are a helpful assistant.\"],\n *   message,\n * ]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class ChatPromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseChatPromptTemplate<RunInput, PartialVariableName>\n  implements ChatPromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"ChatPromptTemplate\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      promptMessages: \"messages\",\n    };\n  }\n\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  validateTemplate = true;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  constructor(input: ChatPromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      const inputVariablesMessages = new Set<string>();\n      for (const promptMessage of this.promptMessages) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (promptMessage instanceof BaseMessage) continue;\n        for (const inputVariable of promptMessage.inputVariables) {\n          inputVariablesMessages.add(inputVariable);\n        }\n      }\n\n      const totalInputVariables = this.inputVariables as string[];\n      const inputVariablesInstance = new Set(\n        this.partialVariables\n          ? totalInputVariables.concat(Object.keys(this.partialVariables))\n          : totalInputVariables\n      );\n      const difference = new Set(\n        [...inputVariablesInstance].filter(\n          (x) => !inputVariablesMessages.has(x)\n        )\n      );\n      if (difference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...difference,\n          ]}\\` are not used in any of the prompt messages.`\n        );\n      }\n      const otherDifference = new Set(\n        [...inputVariablesMessages].filter(\n          (x) => !inputVariablesInstance.has(x)\n        )\n      );\n      if (otherDifference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...otherDifference,\n          ]}\\` are used in prompt messages but not in the prompt template.`\n        );\n      }\n    }\n  }\n\n  _getPromptType(): \"chat\" {\n    return \"chat\";\n  }\n\n  private async _parseImagePrompts(\n    message: BaseMessage,\n    inputValues: InputValues<\n      PartialVariableName | Extract<keyof RunInput, string>\n    >\n  ): Promise<BaseMessage> {\n    if (typeof message.content === \"string\") {\n      return message;\n    }\n    const formattedMessageContent = await Promise.all(\n      message.content.map(async (item) => {\n        if (item.type !== \"image_url\") {\n          return item;\n        }\n\n        let imageUrl = \"\";\n        if (typeof item.image_url === \"string\") {\n          imageUrl = item.image_url;\n        } else if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url &&\n          typeof item.image_url.url === \"string\"\n        ) {\n          imageUrl = item.image_url.url;\n        }\n\n        const promptTemplatePlaceholder = PromptTemplate.fromTemplate(\n          imageUrl,\n          {\n            templateFormat: this.templateFormat,\n          }\n        );\n        const formattedUrl = await promptTemplatePlaceholder.format(\n          inputValues\n        );\n\n        if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url\n        ) {\n          // eslint-disable-next-line no-param-reassign\n          item.image_url.url = formattedUrl;\n        } else {\n          item.image_url = formattedUrl;\n        }\n        return item;\n      })\n    );\n    message.content = formattedMessageContent;\n    return message;\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let resultMessages: BaseMessage[] = [];\n\n    for (const promptMessage of this.promptMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) {\n        resultMessages.push(\n          await this._parseImagePrompts(promptMessage, allValues)\n        );\n      } else {\n        let inputValues: InputValues;\n\n        if (this.templateFormat === \"mustache\") {\n          inputValues = { ...allValues };\n        } else {\n          inputValues = promptMessage.inputVariables.reduce(\n            (acc, inputVariable) => {\n              if (\n                !(inputVariable in allValues) &&\n                !(\n                  isMessagesPlaceholder(promptMessage) && promptMessage.optional\n                )\n              ) {\n                const error = addLangChainErrorFields(\n                  new Error(\n                    `Missing value for input variable \\`${inputVariable.toString()}\\``\n                  ),\n                  \"INVALID_PROMPT_INPUT\"\n                );\n                throw error;\n              }\n              acc[inputVariable] = allValues[inputVariable];\n              return acc;\n            },\n            {} as InputValues\n          );\n        }\n        const message = await promptMessage.formatMessages(inputValues);\n        resultMessages = resultMessages.concat(message);\n      }\n    }\n    return resultMessages;\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    // This is implemented in a way it doesn't require making\n    // BaseMessagePromptTemplate aware of .partial()\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ChatPromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const prompt = PromptTemplate.fromTemplate(template, options);\n    const humanTemplate = new HumanMessagePromptTemplate({ prompt });\n    return this.fromMessages<\n      RunInput extends Symbol ? ParamsFromFString<T> : RunInput\n    >([humanTemplate]);\n  }\n\n  /**\n   * Create a chat model-specific prompt from individual chat messages\n   * or message-like tuples.\n   * @param promptMessages Messages to be passed to the chat model\n   * @returns A new ChatPromptTemplate\n   */\n  static fromMessages<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    Extra extends ChatPromptTemplateInput<RunInput> = ChatPromptTemplateInput<RunInput>\n  >(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >\n  ): ChatPromptTemplate<RunInput> {\n    const flattenedMessages = promptMessages.reduce(\n      (acc: Array<BaseMessagePromptTemplate | BaseMessage>, promptMessage) =>\n        acc.concat(\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          promptMessage instanceof ChatPromptTemplate\n            ? promptMessage.promptMessages\n            : [\n                _coerceMessagePromptTemplateLike<\n                  RunInput,\n                  Omit<\n                    Extra,\n                    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n                  >\n                >(promptMessage, extra),\n              ]\n        ),\n      []\n    );\n    const flattenedPartialVariables = promptMessages.reduce(\n      (acc, promptMessage) =>\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        promptMessage instanceof ChatPromptTemplate\n          ? Object.assign(acc, promptMessage.partialVariables)\n          : acc,\n      Object.create(null) as PartialValues\n    );\n    const inputVariables = new Set<string>();\n    for (const promptMessage of flattenedMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) continue;\n      for (const inputVariable of promptMessage.inputVariables) {\n        if (inputVariable in flattenedPartialVariables) {\n          continue;\n        }\n        inputVariables.add(inputVariable);\n      }\n    }\n    return new this<RunInput>({\n      ...extra,\n      inputVariables: [...inputVariables] as Extract<keyof RunInput, string>[],\n      promptMessages: flattenedMessages,\n      partialVariables: flattenedPartialVariables,\n      templateFormat: extra?.templateFormat,\n    });\n  }\n}\n", "import { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n  Example,\n} from \"./base.js\";\nimport type { BaseExampleSelector } from \"../example_selectors/base.js\";\nimport {\n  type TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\nimport { PromptTemplate } from \"./prompt.js\";\nimport type { SerializedFewShotTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/index.js\";\nimport {\n  BaseChatPromptTemplate,\n  type BaseMessagePromptTemplate,\n} from \"./chat.js\";\n\nexport interface FewShotPromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector;\n\n  /**\n   * An {@link PromptTemplate} used to format a single example.\n   */\n  examplePrompt: PromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   */\n  exampleSeparator?: string;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Prompt template that contains few-shot examples.\n * @augments BasePromptTemplate\n * @augments FewShotPromptTemplateInput\n * @example\n * ```typescript\n * const examplePrompt = PromptTemplate.fromTemplate(\n *   \"Input: {input}\\nOutput: {output}\",\n * );\n *\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n *\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt,\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n *\n * // Format the dynamic prompt with the input 'rainy'\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n *\n * ```\n */\nexport class FewShotPromptTemplate\n  extends BaseStringPromptTemplate\n  implements FewShotPromptTemplateInput\n{\n  lc_serializable = false;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: PromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  constructor(input: FewShotPromptTemplateInput) {\n    super(input);\n    Object.assign(this, input);\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"few_shot\" {\n    return \"few_shot\";\n  }\n\n  static lc_name() {\n    return \"FewShotPromptTemplate\";\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotPromptTemplate(promptDict);\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: InputValues): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n\n    const exampleStrings = await Promise.all(\n      examples.map((example) => this.examplePrompt.format(example))\n    );\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  serialize(): SerializedFewShotTemplate {\n    if (this.exampleSelector || !this.examples) {\n      throw new Error(\n        \"Serializing an example selector is not currently supported\"\n      );\n    }\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Serializing an output parser is not currently supported\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      example_prompt: this.examplePrompt.serialize(),\n      example_separator: this.exampleSeparator,\n      suffix: this.suffix,\n      prefix: this.prefix,\n      template_format: this.templateFormat,\n      examples: this.examples,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedFewShotTemplate\n  ): Promise<FewShotPromptTemplate> {\n    const { example_prompt } = data;\n    if (!example_prompt) {\n      throw new Error(\"Missing example prompt\");\n    }\n    const examplePrompt = await PromptTemplate.deserialize(example_prompt);\n\n    let examples: Example[];\n\n    if (Array.isArray(data.examples)) {\n      examples = data.examples;\n    } else {\n      throw new Error(\n        \"Invalid examples format. Only list or string are supported.\"\n      );\n    }\n\n    return new FewShotPromptTemplate({\n      inputVariables: data.input_variables,\n      examplePrompt,\n      examples,\n      exampleSeparator: data.example_separator,\n      prefix: data.prefix,\n      suffix: data.suffix,\n      templateFormat: data.template_format,\n    });\n  }\n}\n\nexport interface FewShotChatMessagePromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseMessagePromptTemplate} | {@link BaseChatPromptTemplate} used to format a single example.\n   */\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   *\n   * @defaultValue `\"\\n\\n\"`\n   */\n  exampleSeparator?: string;\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   *\n   * @defaultValue `f-string`\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Chat prompt template that contains few-shot examples.\n * @augments BasePromptTemplateInput\n * @augments FewShotChatMessagePromptTemplateInput\n */\nexport class FewShotChatMessagePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseChatPromptTemplate\n  implements FewShotChatMessagePromptTemplateInput\n{\n  lc_serializable = true;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  _getPromptType(): \"few_shot_chat\" {\n    return \"few_shot_chat\";\n  }\n\n  static lc_name() {\n    return \"FewShotChatMessagePromptTemplate\";\n  }\n\n  constructor(fields: FewShotChatMessagePromptTemplateInput) {\n    super(fields);\n\n    this.examples = fields.examples;\n    this.examplePrompt = fields.examplePrompt;\n    this.exampleSeparator = fields.exampleSeparator ?? \"\\n\\n\";\n    this.exampleSelector = fields.exampleSelector;\n    this.prefix = fields.prefix ?? \"\";\n    this.suffix = fields.suffix ?? \"\";\n    this.templateFormat = fields.templateFormat ?? \"f-string\";\n    this.validateTemplate = fields.validateTemplate ?? true;\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  /**\n   * Formats the list of values and returns a list of formatted messages.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let examples = await this.getExamples(allValues);\n\n    examples = examples.map((example) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const result: Record<string, any> = {};\n      this.examplePrompt.inputVariables.forEach((inputVariable) => {\n        result[inputVariable] = example[inputVariable];\n      });\n      return result;\n    });\n\n    const messages: BaseMessage[] = [];\n    for (const example of examples) {\n      const exampleMessages = await this.examplePrompt.formatMessages(example);\n      messages.push(...exampleMessages);\n    }\n    return messages;\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n    const exampleMessages = await Promise.all(\n      examples.map((example) => this.examplePrompt.formatMessages(example))\n    );\n    const exampleStrings = exampleMessages\n      .flat()\n      .map((message) => message.content);\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  /**\n   * Partially formats the prompt with the given values.\n   * @param values The values to partially format the prompt with.\n   * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.\n   */\n  async partial(\n    values: PartialValues<PartialVariableName>\n  ): Promise<FewShotChatMessagePromptTemplate<RunInput, PartialVariableName>> {\n    const newInputVariables = this.inputVariables.filter(\n      (variable) => !(variable in values)\n    ) as Exclude<Extract<keyof RunInput, string>, PartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | PartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotChatMessagePromptTemplate<\n      InputValues<Exclude<Extract<keyof RunInput, string>, PartialVariableName>>\n    >(promptDict);\n  }\n}\n", "import type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { SerializedBasePromptTemplate } from \"./serde.js\";\nimport { BasePromptTemplate, type BasePromptTemplateInput } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n\n/**\n * Type that includes the name of the prompt and the prompt itself.\n */\nexport type PipelinePromptParams<\n  PromptTemplateType extends BasePromptTemplate\n> = {\n  name: string;\n  prompt: PromptTemplateType;\n};\n\n/**\n * Type that extends the BasePromptTemplateInput type, excluding the\n * inputVariables property. It includes an array of pipelinePrompts and a\n * finalPrompt.\n */\nexport type PipelinePromptTemplateInput<\n  PromptTemplateType extends BasePromptTemplate\n> = Omit<BasePromptTemplateInput, \"inputVariables\"> & {\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n  finalPrompt: PromptTemplateType;\n};\n\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate<\n  PromptTemplateType extends BasePromptTemplate\n> extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n\n  finalPrompt: PromptTemplateType;\n\n  constructor(input: PipelinePromptTemplateInput<PromptTemplateType>) {\n    super({ ...input, inputVariables: [] });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  protected computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(\n      (pipelinePrompt) => pipelinePrompt.name\n    );\n    const inputValues = this.pipelinePrompts\n      .map((pipelinePrompt) =>\n        pipelinePrompt.prompt.inputVariables.filter(\n          (inputValue) => !intermediateValues.includes(inputValue)\n        )\n      )\n      .flat();\n    return [...new Set(inputValues)];\n  }\n\n  protected static extractRequiredInputValues(\n    allValues: InputValues,\n    requiredValueNames: string[]\n  ) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {} as InputValues);\n  }\n\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  protected async formatPipelinePrompts(\n    values: InputValues\n  ): Promise<InputValues> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n      .pipelinePrompts) {\n      const pipelinePromptInputValues =\n        PipelinePromptTemplate.extractRequiredInputValues(\n          allValues,\n          pipelinePrompt.inputVariables\n        );\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(\n          pipelinePromptInputValues\n        );\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(\n          pipelinePromptInputValues\n        );\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(\n      allValues,\n      this.finalPrompt.inputVariables\n    );\n  }\n\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(\n    values: InputValues\n  ): Promise<PromptTemplateType[\"PromptValueReturnType\"]> {\n    return this.finalPrompt.formatPromptValue(\n      await this.formatPipelinePrompts(values)\n    );\n  }\n\n  async format(values: InputValues): Promise<string> {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(\n    values: PartialValues\n  ): Promise<PipelinePromptTemplate<PromptTemplateType>> {\n    const promptDict = { ...this };\n    promptDict.inputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    return new PipelinePromptTemplate<PromptTemplateType>(promptDict);\n  }\n\n  serialize(): SerializedBasePromptTemplate {\n    throw new Error(\"Not implemented.\");\n  }\n\n  _getPromptType(): string {\n    return \"pipeline\";\n  }\n}\n", "import { ChatPromptValueInterface } from \"../prompt_values.js\";\nimport { RunnableLike, Runnable, RunnableBinding } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { InputValues } from \"../utils/types/index.js\";\nimport {\n  BaseMessagePromptTemplateLike,\n  ChatPromptTemplate,\n  ChatPromptTemplateInput,\n} from \"./chat.js\";\n\nfunction isWithStructuredOutput(x: unknown): x is {\n  withStructuredOutput: (...arg: unknown[]) => Runnable;\n} {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"withStructuredOutput\" in x &&\n    typeof x.withStructuredOutput === \"function\"\n  );\n}\n\nfunction isRunnableBinding(x: unknown): x is RunnableBinding<unknown, unknown> {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"lc_id\" in x &&\n    Array.isArray(x.lc_id) &&\n    x.lc_id.join(\"/\") === \"langchain_core/runnables/RunnableBinding\"\n  );\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface StructuredPromptInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends ChatPromptTemplateInput<RunInput, PartialVariableName> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n}\n\nexport class StructuredPrompt<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends ChatPromptTemplate<RunInput, PartialVariableName>\n  implements StructuredPromptInput<RunInput, PartialVariableName>\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"structured\"];\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      ...super.lc_aliases,\n      schema: \"schema_\",\n    };\n  }\n\n  constructor(input: StructuredPromptInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.schema = input.schema;\n    this.method = input.method;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<ChatPromptValueInterface, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>, RunnableConfig> {\n    if (isWithStructuredOutput(coerceable)) {\n      return super.pipe(coerceable.withStructuredOutput(this.schema));\n    }\n\n    if (\n      isRunnableBinding(coerceable) &&\n      isWithStructuredOutput(coerceable.bound)\n    ) {\n      return super.pipe(\n        new RunnableBinding({\n          bound: coerceable.bound.withStructuredOutput(\n            this.schema,\n            ...(this.method ? [{ method: this.method }] : [])\n          ),\n          kwargs: coerceable.kwargs ?? {},\n          config: coerceable.config,\n          configFactories: coerceable.configFactories,\n        })\n      );\n    }\n\n    throw new Error(\n      `Structured prompts need to be piped to a language model that supports the \"withStructuredOutput()\" method.`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromMessagesAndSchema<RunInput extends InputValues = any>(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    schema: StructuredPromptInput[\"schema\"],\n    method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\"\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): ChatPromptTemplate<RunInput, any> {\n    return StructuredPrompt.fromMessages<\n      RunInput,\n      StructuredPromptInput<RunInput>\n    >(promptMessages, { schema, method });\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { BasePromptTemplate } from \"./base.js\";\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, checkValidTemplate, interpolateFString, interpolateMustache, parseFString, parseMustache, parseTemplate, renderTemplate } from \"./template.js\";\nimport { PromptTemplate } from \"./prompt.js\";\nimport { ImagePromptTemplate } from \"./image.js\";\nimport { DictPromptTemplate } from \"./dict.js\";\nimport { AIMessagePromptTemplate, BaseChatPromptTemplate, BaseMessagePromptTemplate, BaseMessageStringPromptTemplate, ChatMessagePromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate, MessagesPlaceholder, SystemMessagePromptTemplate } from \"./chat.js\";\nimport { FewShotChatMessagePromptTemplate, FewShotPromptTemplate } from \"./few_shot.js\";\nimport { PipelinePromptTemplate } from \"./pipeline.js\";\nimport { StructuredPrompt } from \"./structured.js\";\n\n//#region src/prompts/index.ts\nvar prompts_exports = {};\n__export(prompts_exports, {\n\tAIMessagePromptTemplate: () => AIMessagePromptTemplate,\n\tBaseChatPromptTemplate: () => BaseChatPromptTemplate,\n\tBaseMessagePromptTemplate: () => BaseMessagePromptTemplate,\n\tBaseMessageStringPromptTemplate: () => BaseMessageStringPromptTemplate,\n\tBasePromptTemplate: () => BasePromptTemplate,\n\tBaseStringPromptTemplate: () => BaseStringPromptTemplate,\n\tChatMessagePromptTemplate: () => ChatMessagePromptTemplate,\n\tChatPromptTemplate: () => ChatPromptTemplate,\n\tDEFAULT_FORMATTER_MAPPING: () => DEFAULT_FORMATTER_MAPPING,\n\tDEFAULT_PARSER_MAPPING: () => DEFAULT_PARSER_MAPPING,\n\tDictPromptTemplate: () => DictPromptTemplate,\n\tFewShotChatMessagePromptTemplate: () => FewShotChatMessagePromptTemplate,\n\tFewShotPromptTemplate: () => FewShotPromptTemplate,\n\tHumanMessagePromptTemplate: () => HumanMessagePromptTemplate,\n\tImagePromptTemplate: () => ImagePromptTemplate,\n\tMessagesPlaceholder: () => MessagesPlaceholder,\n\tPipelinePromptTemplate: () => PipelinePromptTemplate,\n\tPromptTemplate: () => PromptTemplate,\n\tStructuredPrompt: () => StructuredPrompt,\n\tSystemMessagePromptTemplate: () => SystemMessagePromptTemplate,\n\tcheckValidTemplate: () => checkValidTemplate,\n\tinterpolateFString: () => interpolateFString,\n\tinterpolateMustache: () => interpolateMustache,\n\tparseFString: () => parseFString,\n\tparseMustache: () => parseMustache,\n\tparseTemplate: () => parseTemplate,\n\trenderTemplate: () => renderTemplate\n});\n\n//#endregion\nexport { AIMessagePromptTemplate, BaseChatPromptTemplate, BaseMessagePromptTemplate, BaseMessageStringPromptTemplate, BasePromptTemplate, BaseStringPromptTemplate, ChatMessagePromptTemplate, ChatPromptTemplate, DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, DictPromptTemplate, FewShotChatMessagePromptTemplate, FewShotPromptTemplate, HumanMessagePromptTemplate, ImagePromptTemplate, MessagesPlaceholder, PipelinePromptTemplate, PromptTemplate, StructuredPrompt, SystemMessagePromptTemplate, checkValidTemplate, interpolateFString, interpolateMustache, parseFString, parseMustache, parseTemplate, prompts_exports, renderTemplate };\n//# sourceMappingURL=index.js.map"],
  "mappings": "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",
  "names": ["input: BasePromptTemplateInput", "userVariables: TypedPromptInputValues<RunInput>", "partialValues: Record<string, string>", "input: RunInput", "options?: BaseCallbackConfig", "input", "value: string", "fields: BaseMessage[] | ChatPromptValueFields", "fields: ImageContent | ImagePromptValueFields", "values: TypedPromptInputValues<RunInput>", "clearCache", "parse", "render", "template: string", "nodes: ParsedTemplateNode[]", "bracket: \"}\" | \"{\" | \"{}\"", "start: number", "i", "template: mustache.TemplateSpans", "context: string[]", "values: InputValues", "DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator>", "DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser>", "templateFormat: TemplateFormat", "inputValues: InputValues", "parseTemplate", "template: MessageContent", "inputVariables: string[]", "dummyInputs: InputValues", "e: any", "PromptTemplate", "input: PromptTemplateInput<RunInput, PartialVariableName>", "totalInputVariables: string[]", "values: TypedPromptInputValues<RunInput>", "examples: string[]", "suffix: string", "inputVariables: string[]", "template: T", "options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >", "parseTemplate", "values: PartialValues<NewPartialVariableName>", "data: SerializedPromptTemplate", "ImagePromptTemplate", "input: ImagePromptTemplateInput<RunInput, PartialVariableName>", "totalInputVariables: string[]", "values: PartialValues<NewPartialVariableName>", "values: TypedPromptInputValues<RunInput>", "formatted: Record<string, any>", "output: ImageContent", "fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }", "values: TypedPromptInputValues<RunInput>", "values: TypedPromptInputValues<InputValues>", "template: Record<string, unknown>", "templateFormat: TemplateFormat", "inputVariables: Array<Extract<keyof InputValues, string>>", "parseTemplate", "inputs: TypedPromptInputValues<InputValues>", "formatted: Record<string, unknown>", "formattedV: Array<unknown>", "input: RunInput", "options?: BaseCallbackConfig", "input", "fields:\n      | Extract<keyof RunInput, string>\n      | MessagesPlaceholderFields<Extract<keyof RunInput, string>>", "values: TypedPromptInputValues<RunInput>", "e: any", "fields:\n      | MessageStringPromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<\n          InputValues<Extract<keyof RunInput, string>>,\n          string\n        >", "input: BasePromptTemplateInput<RunInput, PartialVariableName>", "fields:\n      | ChatMessagePromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<InputValues<Extract<keyof RunInput, string>>>", "role?: string", "values: RunInput", "template: T", "role: string", "options?: { templateFormat?: TemplateFormat }", "param: unknown", "fields: any", "additionalOptions?: _StringImageMessagePromptTemplateOptions", "inputVariables: Extract<keyof RunInput, string>[]", "content: MessageContent", "name: string", "template:\n      | string\n      | Array<\n          | string\n          | _TextTemplateParam\n          | _ImageTemplateParam\n          | Record<string, unknown>\n        >", "prompt: Array<\n      | PromptTemplate<InputValues>\n      | ImagePromptTemplate<InputValues>\n      | DictPromptTemplate\n    >", "imgTemplateObject: ImagePromptTemplate<InputValues>", "inputVariables: string[]", "parsedTemplate: ParsedTemplateNode[]", "item", "input: TypedPromptInputValues<RunInput>", "inputs: Record<string, any>", "additionalContentFields: ContentBlock | undefined", "baseMessagePromptTemplateLike: BaseMessagePromptTemplateLike", "messagePromptTemplateLike: BaseMessagePromptTemplateLike", "extra?: Extra", "templateData:\n    | string\n    | (\n        | string\n        | _TextTemplateParam\n        | _ImageTemplateParam\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | Record<string, any>\n      )[]", "x: BaseMessagePromptTemplate | BaseMessage", "ChatPromptTemplate", "input: ChatPromptTemplateInput<RunInput, PartialVariableName>", "message: BaseMessage", "inputValues: InputValues<\n      PartialVariableName | Extract<keyof RunInput, string>\n    >", "resultMessages: BaseMessage[]", "inputValues: InputValues", "values: PartialValues<NewPartialVariableName>", "options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >", "promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[]", "extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >", "acc: Array<BaseMessagePromptTemplate | BaseMessage>", "FewShotPromptTemplate", "input: FewShotPromptTemplateInput", "totalInputVariables: string[]", "inputVariables: InputValues", "values: PartialValues<NewPartialVariableName>", "values: InputValues", "data: SerializedFewShotTemplate", "examples: Example[]", "FewShotChatMessagePromptTemplate", "fields: FewShotChatMessagePromptTemplateInput", "values: TypedPromptInputValues<RunInput>", "result: Record<string, any>", "messages: BaseMessage[]", "values: PartialValues<PartialVariableName>", "PipelinePromptTemplate", "input: PipelinePromptTemplateInput<PromptTemplateType>", "allValues: InputValues", "requiredValueNames: string[]", "values: InputValues", "values: PartialValues", "x: unknown", "StructuredPrompt", "input: StructuredPromptInput<RunInput, PartialVariableName>", "coerceable: RunnableLike<ChatPromptValueInterface, NewRunOutput>", "promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[]", "schema: StructuredPromptInput[\"schema\"]", "method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\"", "parseTemplate"]
}

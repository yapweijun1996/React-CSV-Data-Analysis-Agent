const E=(e,t)=>t.some(n=>e instanceof n);let M,O;function q(){return M||(M=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function H(){return O||(O=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const B=new WeakMap,v=new WeakMap,I=new WeakMap;function z(e){const t=new Promise((n,o)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",c)},s=()=>{n(d(e.result)),r()},c=()=>{o(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",c)});return I.set(t,e),t}function G(e){if(B.has(e))return;const t=new Promise((n,o)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",c),e.removeEventListener("abort",c)},s=()=>{n(),r()},c=()=>{o(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",c),e.addEventListener("abort",c)});B.set(e,t)}let P={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return B.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return d(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function $(e){P=e(P)}function J(e){return H().includes(e)?function(...t){return e.apply(k(this),t),d(this.request)}:function(...t){return d(e.apply(k(this),t))}}function Q(e){return typeof e=="function"?J(e):(e instanceof IDBTransaction&&G(e),E(e,q())?new Proxy(e,P):e)}function d(e){if(e instanceof IDBRequest)return z(e);if(v.has(e))return v.get(e);const t=Q(e);return t!==e&&(v.set(e,t),I.set(t,e)),t}const k=e=>I.get(e);function X(e,t,{blocked:n,upgrade:o,blocking:r,terminated:s}={}){const c=indexedDB.open(e,t),i=d(c);return o&&c.addEventListener("upgradeneeded",a=>{o(d(c.result),a.oldVersion,a.newVersion,d(c.transaction),a)}),n&&c.addEventListener("blocked",a=>n(a.oldVersion,a.newVersion,a)),i.then(a=>{s&&a.addEventListener("close",()=>s()),r&&a.addEventListener("versionchange",u=>r(u.oldVersion,u.newVersion,u))}).catch(()=>{}),i}const Y=["get","getKey","getAll","getAllKeys","count"],Z=["put","add","delete","clear"],C=new Map;function R(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(C.get(t))return C.get(t);const n=t.replace(/FromIndex$/,""),o=t!==n,r=Z.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(r||Y.includes(n)))return;const s=async function(c,...i){const a=this.transaction(c,r?"readwrite":"readonly");let u=a.store;return o&&(u=u.index(i.shift())),(await Promise.all([u[n](...i),r&&a.done]))[0]};return C.set(t,s),s}$(e=>({...e,get:(t,n,o)=>R(t,n)||e.get(t,n,o),has:(t,n)=>!!R(t,n)||e.has(t,n)}));const tt=["continue","continuePrimaryKey","advance"],A={},x=new WeakMap,W=new WeakMap,et={get(e,t){if(!tt.includes(t))return e[t];let n=A[t];return n||(n=A[t]=function(...o){x.set(this,W.get(this)[t](...o))}),n}};async function*nt(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,et);for(W.set(n,t),I.set(n,k(t));t;)yield n,t=await(x.get(n)||t.continue()),x.delete(n)}function _(e,t){return t===Symbol.asyncIterator&&E(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&E(e,[IDBIndex,IDBObjectStore])}$(e=>({...e,get(t,n,o){return _(t,n)?nt:e.get(t,n,o)},has(t,n){return _(t,n)||e.has(t,n)}}));const T="csv_agent_db",ot=2,m="provenance";let y=null;const l=e=>({clean:`clean_rows_${e}`,columns:`columns_${e}`,views:`views_${e}`}),L=(e,t)=>{if(!e.objectStoreNames.contains(t)){if(t.startsWith("clean_rows_")){e.createObjectStore(t,{keyPath:"chunkId"});return}if(t.startsWith("columns_")){e.createObjectStore(t,{keyPath:"id"});return}if(t.startsWith("views_")){e.createObjectStore(t,{keyPath:"id"});return}if(t===m){e.createObjectStore(t,{keyPath:"datasetId"});return}throw new Error(`Unsupported store name: ${t}`)}},V=async e=>{try{return await e()}catch(t){if(t instanceof DOMException&&t.name==="VersionError")return console.warn("IndexedDB version mismatch detected. Resetting csv_agent_db...",t),await new Promise((n,o)=>{const r=indexedDB.deleteDatabase(T);r.onsuccess=()=>n(),r.onerror=()=>o(r.error),r.onblocked=()=>console.warn("Delete csv_agent_db blocked. Close other tabs.")}),e();throw t}},w=async(e=[])=>{const t=(s,c)=>X(T,s,{upgrade(i){L(i,m),c.forEach(a=>L(i,a))}});if(!y)return y=V(()=>t(ot,e)),y;const n=await y,o=e.filter(s=>!n.objectStoreNames.contains(s));if(o.length===0)return n;n.close();const r=n.version+1;return y=V(()=>t(r,[...e,...o])),y},rt=(e,t)=>{const n=[];for(let o=0;o<e.length;o+=t)n.push(e.slice(o,o+t));return n},ct=async e=>{const{datasetId:t,rows:n,columns:o,provenance:r,chunkSize:s=2e4}=e;if(!t)throw new Error("persistCleanDataset requires datasetId.");const c=Object.values(l(t)),i=await w(c),{clean:a,columns:u}=l(t),f=i.transaction([a,u,m],"readwrite"),b=f.objectStore(a),D=f.objectStore(u),S=f.objectStore(m);await b.clear();const g=rt(n,s),j=new Date().toISOString();for(let h=0;h<g.length;h+=1){const p=g[h],K={chunkId:`${t}-chunk-${h}`,rowCount:p.length,startRow:h*s,endRow:h*s+p.length-1,rows:p,createdAt:j};await b.put(K)}const F={id:"columns",columnCount:o.length,columns:o,rowCount:n.length,updatedAt:j};await D.put(F);const U={datasetId:t,fileName:r.fileName,bytes:r.bytes,checksum:r.checksum,cleanedAt:r.cleanedAt};return await S.put(U),await f.done,{chunkCount:g.length,rowCount:n.length}},at=async e=>{const{datasetId:t,title:n,kind:o,queryHash:r,explainer:s,dataRef:c}=e,{views:i}=l(t),u=(await w([i])).transaction(i,"readwrite"),f=u.objectStore(i),b=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,D=`${t}-view-${b}`,S={id:D,title:n,kind:o,queryHash:r,explainer:s,dataRef:c,createdAt:new Date().toISOString()};return await f.put(S),await u.done,D},it=async e=>{const{views:t}=l(e),n=await w([t]);try{const o=n.transaction(t,"readonly"),s=await o.objectStore(t).getAll();return await o.done,s}catch(o){return console.warn(`Failed to read card results for ${e}`,o),[]}},ut=async e=>{const n=(await w()).transaction(m,"readonly"),r=await n.objectStore(m).get(e);return await n.done,r??void 0},st=async e=>{const{columns:t}=l(e),o=(await w([t])).transaction(t,"readonly"),s=await o.objectStore(t).get("columns");return await o.done,s??null},dt=async e=>{const t=await st(e);return(t==null?void 0:t.columns)??null},N=async(e,t)=>{const{clean:n}=l(e),r=(await w([n])).transaction(n,"readonly"),s=r.objectStore(n);let c=!1;const i=()=>{c=!0};let a=await s.openCursor();for(;a&&!c;){const u=a.value;if(await t(u,i),c)break;a=await a.continue()}await r.done},lt=async(e,t)=>{const n=[];return await N(e,(o,r)=>{for(const s of o.rows)if(n.push(s),n.length>=t){r();break}}),n},wt=async e=>{const t=[];return await N(e,n=>{t.push(...n.rows)}),t},ft=async e=>{const{views:t}=l(e),o=(await w([t])).transaction(t,"readwrite");await o.objectStore(t).clear(),await o.done};export{ft as clearCardResults,ct as persistCleanDataset,wt as readAllRows,it as readCardResults,dt as readColumnProfiles,st as readColumnStoreRecord,ut as readProvenance,lt as readSampledRows,at as saveCardResult};

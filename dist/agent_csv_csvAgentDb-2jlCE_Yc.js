import{c as ge,m as ye,h as me,p as he,s as be}from"./agent_csv_dataWorker-BBZr3Tqp.js";const L=(e,t)=>t.some(r=>e instanceof r);let K,N;function Se(){return K||(K=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function De(){return N||(N=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const B=new WeakMap,k=new WeakMap,O=new WeakMap;function xe(e){const t=new Promise((r,n)=>{const o=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{r(x(e.result)),o()},s=()=>{n(e.error),o()};e.addEventListener("success",a),e.addEventListener("error",s)});return O.set(t,e),t}function Ie(e){if(B.has(e))return;const t=new Promise((r,n)=>{const o=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{r(),o()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),o()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)});B.set(e,t)}let $={get(e,t,r){if(e instanceof IDBTransaction){if(t==="done")return B.get(e);if(t==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return x(e[t])},set(e,t,r){return e[t]=r,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function re(e){$=e($)}function _e(e){return De().includes(e)?function(...t){return e.apply(q(this),t),x(this.request)}:function(...t){return x(e.apply(q(this),t))}}function ve(e){return typeof e=="function"?_e(e):(e instanceof IDBTransaction&&Ie(e),L(e,Se())?new Proxy(e,$):e)}function x(e){if(e instanceof IDBRequest)return xe(e);if(k.has(e))return k.get(e);const t=ve(e);return t!==e&&(k.set(e,t),O.set(t,e)),t}const q=e=>O.get(e);function ne(e,t,{blocked:r,upgrade:n,blocking:o,terminated:a}={}){const s=indexedDB.open(e,t),i=x(s);return n&&s.addEventListener("upgradeneeded",c=>{n(x(s.result),c.oldVersion,c.newVersion,x(s.transaction),c)}),r&&s.addEventListener("blocked",c=>r(c.oldVersion,c.newVersion,c)),i.then(c=>{a&&c.addEventListener("close",()=>a()),o&&c.addEventListener("versionchange",d=>o(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const Ae=["get","getKey","getAll","getAllKeys","count"],Ce=["put","add","delete","clear"],P=new Map;function Y(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(P.get(t))return P.get(t);const r=t.replace(/FromIndex$/,""),n=t!==r,o=Ce.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(o||Ae.includes(r)))return;const a=async function(s,...i){const c=this.transaction(s,o?"readwrite":"readonly");let d=c.store;return n&&(d=d.index(i.shift())),(await Promise.all([d[r](...i),o&&c.done]))[0]};return P.set(t,a),a}re(e=>({...e,get:(t,r,n)=>Y(t,r)||e.get(t,r,n),has:(t,r)=>!!Y(t,r)||e.has(t,r)}));const pe=["continue","continuePrimaryKey","advance"],X={},V=new WeakMap,oe=new WeakMap,Ee={get(e,t){if(!pe.includes(t))return e[t];let r=X[t];return r||(r=X[t]=function(...n){V.set(this,oe.get(this)[t](...n))}),r}};async function*Re(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const r=new Proxy(t,Ee);for(oe.set(r,t),O.set(r,q(t));t;)yield r,t=await(V.get(r)||t.continue()),V.delete(r)}function J(e,t){return t===Symbol.asyncIterator&&L(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&L(e,[IDBIndex,IDBObjectStore])}re(e=>({...e,get(t,r,n){return J(t,r)?Re:e.get(t,r,n)},has(t,r){return J(t,r)||e.has(t,r)}}));const U="csv_agent_db",Q=6,I="provenance",g="clean_rows",f="columns",w="views",y="preparation_log",m="memory_snapshots",h="dataset_runtime_config",C="system_meta",b="audit_logs",ae=400,Z="csv_agent_db is in read-only fallback because the last migration failed. Close other tabs or clear site data, then reload.",Oe=32;let D=null,R=null,F=!1,v=null;const A=[],Te=e=>{if(!(e!=null&&e.stringStrategy))return!0;const{caseStrategy:t,trimWhitespace:r,nullReplacement:n}=e.stringStrategy;return typeof r!="boolean"||t!=="as-is"&&t!=="lower"||typeof n!="string"||n.length===0},Me=async e=>{const t=me(e??null);return e&&t&&Te(e)&&await W(t),t},p=()=>typeof crypto<"u"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,ke=[{version:1,description:"Initialize core CSV Agent object stores.",up:e=>{[I,g,f,w,y,m,h].forEach(r=>j(e,r))}},{version:5,description:"Add system meta store for migration logging.",up:e=>{j(e,C)}},{version:6,description:"Add audit log store for runtime events.",up:e=>{j(e,b)}}],Pe=e=>{var t;if((t=e==null?void 0:e.db)!=null&&t.objectStoreNames.contains(C))try{const r=e.objectStore(C);for(;A.length>0;){const n=A[0];r.put(n),A.shift()}}catch(r){console.warn("Failed to persist migration log entry.",r)}},ee=(e,t)=>{const r={id:`migration-${t.version}-${p()}`,type:"migration",version:t.version,description:t.description,status:t.status,error:t.error??null,createdAt:new Date().toISOString()};A.push(r),Pe(e)},je=(e,t,r,n)=>{if(!n)return;const o=ke.filter(a=>a.version>r&&a.version<=n).sort((a,s)=>a.version-s.version);for(const a of o)try{a.up(e,t),ee(t,{version:a.version,description:a.description,status:"succeeded"})}catch(s){throw v=a.version,ee(t,{version:a.version,description:a.description,status:"failed",error:s instanceof Error?s.message:String(s)}),s}},Le=(e,t)=>{const r=t.filter(n=>!e.objectStoreNames.contains(n));if(r.length>0)throw new Error(`Missing object stores: ${r.join(", ")}`)},te=async()=>(R||(R=ne(U,void 0,{blocked:()=>console.warn("csv_agent_db read-only open is blocked by another tab.")})),R),se=async()=>{await new Promise((e,t)=>{const r=indexedDB.deleteDatabase(U);r.onsuccess=()=>e(),r.onerror=()=>t(r.error),r.onblocked=()=>console.warn("IndexedDB delete blocked. Close other tabs to proceed.")}),D=null,R=null,F=!1,v=null,A.length=0},j=(e,t)=>{if(!e.objectStoreNames.contains(t)){if(t===g){e.createObjectStore(t,{keyPath:"chunkId"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===f){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===w){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===I){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===y){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===m){const r=e.createObjectStore(t,{keyPath:"id"});r.createIndex("by_dataset","datasetId",{unique:!1}),r.createIndex("by_view","viewId",{unique:!1});return}if(t===h){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===C){const r=e.createObjectStore(t,{keyPath:"id"});r.createIndex("by_type","type",{unique:!1}),r.createIndex("by_version","version",{unique:!1});return}if(t===b){const r=e.createObjectStore(t,{keyPath:"id"});r.createIndex("by_kind","kind",{unique:!1}),r.createIndex("by_created_at","createdAt",{unique:!1});return}throw new Error(`Unsupported store name: ${t}`)}},Be=async e=>{try{return await e()}catch(t){if(t instanceof DOMException&&t.name==="VersionError")return console.warn("IndexedDB version mismatch detected. Resetting csv_agent_db...",t),await se(),e();throw t}},$e=[I,g,f,w,y,m,h,C,b],u=async(e=[],t)=>{const r=(t==null?void 0:t.mode)??"readonly",n=Array.from(new Set([...$e,...e]));if(F){if(r==="readwrite")throw new Error(Z);return te()}D||(v=null,D=Be(()=>ne(U,Q,{upgrade(o,a,s,i){je(o,i,a,s??Q)},blocked:()=>console.warn("csv_agent_db upgrade is blocked by another tab."),blocking:()=>console.warn("csv_agent_db upgrade is blocking existing tabs. Reload others to proceed."),terminated:()=>{D=null}})));try{const o=await D;return Le(o,n),o}catch(o){if(v!==null){if(console.error(`csv_agent_db migration to version ${v} failed; entering read-only fallback.`,o),F=!0,D=null,r==="readwrite")throw new Error(Z);return te()}throw D=null,o}},qe=(e,t)=>{const r=[];for(let n=0;n<e.length;n+=t)r.push(e.slice(n,n+t));return r},Xe=async e=>{const{datasetId:t,rows:r,columns:n,provenance:o,chunkSize:a=2e4}=e;if(!t)throw new Error("persistCleanDataset requires datasetId.");const s=async c=>{const l=(await u([g,f,w],{mode:"readwrite"})).transaction([g,f,I],"readwrite"),S=l.objectStore(g),de=l.objectStore(f),ue=l.objectStore(I),T=qe(r,a),z=new Date().toISOString();try{let E=await S.index("by_dataset").openCursor(t);for(;E;)await E.delete(),E=await E.continue();for(let _=0;_<T.length;_+=1){const M=T[_],fe={chunkId:`${t}-chunk-${_}`,datasetId:t,rowCount:M.length,startRow:_*a,endRow:_*a+M.length-1,rows:M,createdAt:z};await S.put(fe)}const le={datasetId:t,columnCount:n.length,columns:n,rowCount:r.length,updatedAt:z};await de.put(le);const we={datasetId:t,fileName:o.fileName,bytes:o.bytes,checksum:o.checksum,cleanedAt:o.cleanedAt,normalization:be(c.stringStrategy)};return await ue.put(we),await l.done,{chunkCount:T.length,rowCount:r.length}}catch(G){try{l.abort()}catch{}throw await l.done.catch(()=>{}),G}},i=async()=>{const c=await ie(t,{rowCountHint:r.length});return s(c)};try{return await i()}catch(c){if(c instanceof DOMException&&c.name==="NotFoundError")return console.warn("IndexedDB store missing detected. Resetting and retrying persist...",c),await se(),i();throw c}},Je=async e=>{const{datasetId:t,title:r,kind:n,queryHash:o,explainer:a,dataRef:s}=e,c=(await u([w],{mode:"readwrite"})).transaction(w,"readwrite"),d=c.objectStore(w),l=`${t}-view-${p()}`,S={id:l,datasetId:t,title:r,kind:n,queryHash:o,explainer:a,dataRef:s,createdAt:new Date().toISOString()};return await d.put(S),await c.done,l},Qe=async e=>{const t=await u([w]);try{const r=t.transaction(w,"readonly"),a=await r.objectStore(w).index("by_dataset").getAll(e);return await r.done,a}catch(r){return console.warn(`Failed to read card results for ${e}`,r),[]}},Ze=async e=>{const r=(await u()).transaction(I,"readonly"),o=await r.objectStore(I).get(e);return await r.done,o??void 0},ce=async e=>{const r=(await u([f])).transaction(f,"readonly"),o=await r.objectStore(f).get(e);return await r.done,o??null},et=async e=>{const t=await ce(e);return(t==null?void 0:t.columns)??null},H=async(e,t)=>{const n=(await u([g])).transaction(g,"readonly"),a=n.objectStore(g).index("by_dataset");let s=!1;const i=()=>{s=!0};let c=await a.openCursor(e);for(;c&&!s;){const d=c.value;if(await t(d,i),s)break;c=await c.continue()}await n.done},Ve=async e=>{let t=0;return await H(e,r=>{const n=typeof r.rowCount=="number"?r.rowCount:r.rows.length;t+=n}),t};async function Fe(e){const r=(await u([h])).transaction(h,"readonly"),o=await r.objectStore(h).get(e);return await r.done,Me(o)}async function W(e){const r=(await u([h],{mode:"readwrite"})).transaction(h,"readwrite");await r.objectStore(h).put(e),await r.done}async function ie(e,t){const r=await Fe(e);if(r)return r;const n=ge(e,{rowCountHint:t==null?void 0:t.rowCountHint,preferredMode:t==null?void 0:t.preferredMode});return await W(n),n}async function tt(e,t,r){const n=await ie(e,{rowCountHint:r==null?void 0:r.rowCountHint}),o=ye(n,t);return await W(o),o}const Ue=async(e,t)=>{const r=[];return await H(e,(n,o)=>{for(const a of n.rows)if(r.push(a),r.length>=t){o();break}}),r},rt=async e=>{const t=[];return await H(e,r=>{t.push(...r.rows)}),t},He=(e,t)=>{const r=new Date().toISOString();return t.map((n,o)=>({...n,datasetId:e,id:n.id??`${e}-prep-${p()}`,stepOrder:typeof n.stepOrder=="number"?n.stepOrder:o,scope:n.scope??"dataset",columnName:n.columnName??null,source:n.source??"ai_plan",tags:n.tags??[],createdAt:n.createdAt??r}))},nt=async(e,t=[])=>{if(!e)throw new Error("replacePreparationLog requires datasetId.");const n=(await u([y],{mode:"readwrite"})).transaction(y,"readwrite"),o=n.objectStore(y);let s=await o.index("by_dataset").openCursor(e);for(;s;)await s.delete(),s=await s.continue();if(t.length>0){const i=He(e,t).sort((c,d)=>c.stepOrder-d.stepOrder||new Date(c.createdAt).getTime()-new Date(d.createdAt).getTime());for(const c of i)await o.put(c)}await n.done},ot=async e=>{if(!e)return[];const t=await u([y]);try{const r=t.transaction(y,"readonly"),a=await r.objectStore(y).index("by_dataset").getAll(e);return await r.done,a.sort((s,i)=>s.stepOrder-i.stepOrder||new Date(s.createdAt).getTime()-new Date(i.createdAt).getTime())}catch(r){return console.warn(`Failed to read preparation log for ${e}`,r),[]}},We=async(e,t,r=Oe)=>{const n=await e.index("by_dataset").getAll(t);if(n.length<=r)return;const o=n.sort((i,c)=>{const d=(c.qualityScore??0)-(i.qualityScore??0);return d!==0?d:new Date(c.createdAt).getTime()-new Date(i.createdAt).getTime()}).slice(0,r),a=new Set(o.map(i=>i.id)),s=n.filter(i=>!a.has(i.id));for(const i of s)await e.delete(i.id)},at=async e=>{var a,s;if(!e.datasetId)throw new Error("saveMemorySnapshot requires datasetId.");const r=(await u([m],{mode:"readwrite"})).transaction(m,"readwrite"),n=r.objectStore(m),o={...e,id:e.id??e.viewId??e.cardId??`${e.datasetId}-memo-${p()}`,createdAt:e.createdAt??new Date().toISOString(),plan:e.plan??null,viewId:e.viewId??null,cardId:e.cardId??null,summary:e.summary??"",title:e.title??"Untitled View",sampleRows:e.sampleRows??[],tags:e.tags??[],chartType:e.chartType??((a=e.plan)==null?void 0:a.chartType),queryHash:e.queryHash??null,rowCount:typeof e.rowCount=="number"?e.rowCount:((s=e.sampleRows)==null?void 0:s.length)??0,sampled:e.sampled??!1,expiresAt:e.expiresAt??null};return await n.put(o),await We(n,o.datasetId),await r.done,o.id},st=async(e,t)=>{if(!e)return[];const r=await u([m]);try{const n=r.transaction(m,"readonly"),s=await n.objectStore(m).index("by_dataset").getAll(e);await n.done;const i=s.filter(d=>t!=null&&t.minScore?(d.qualityScore??0)>=t.minScore:!0).filter(d=>{var l;return t!=null&&t.tag?(l=d.tags)==null?void 0:l.includes(t.tag):!0}).sort((d,l)=>{const S=(l.qualityScore??0)-(d.qualityScore??0);return S!==0?S:new Date(l.createdAt).getTime()-new Date(d.createdAt).getTime()}),c=(t==null?void 0:t.limit)??i.length;return i.slice(0,c)}catch(n){return console.warn(`Failed to read memory snapshots for ${e}`,n),[]}},ze=2e3,Ge=async e=>{try{const[t,r]=await Promise.all([Ue(e,ze),Ve(e)]);if(r===0||t.length===0)return console.warn(`CSV Agent: unable to rebuild column metadata for ${e} because the dataset has no cached rows.`),null;const n=he(t),o={datasetId:e,columnCount:n.length,columns:n,rowCount:r,updatedAt:new Date().toISOString()},s=(await u([f],{mode:"readwrite"})).transaction(f,"readwrite");return await s.objectStore(f).put(o),await s.done,console.info(`CSV Agent: rebuilt missing column metadata for dataset ${e}.`),o}catch(t){return console.error(`CSV Agent: failed to rebuild column metadata for dataset ${e}.`,t),null}},ct=async e=>{const t=await ce(e);return t||Ge(e)},it=async e=>{const r=(await u([w],{mode:"readwrite"})).transaction(w,"readwrite");let a=await r.objectStore(w).index("by_dataset").openCursor(e);for(;a;)await a.delete(),a=await a.continue();await r.done},Ke=e=>({id:e.id??`audit-${Date.now()}-${p()}`,kind:e.kind,severity:e.severity,message:e.message,details:e.details??null,tags:e.tags??[],createdAt:e.createdAt??new Date().toISOString()}),Ne=async(e,t)=>{if(t<=0)return;const r=e.index("by_created_at"),n=await r.count();if(n<=t)return;let o=await r.openCursor(void 0,"next"),a=n-t;for(;o&&a>0;)await o.delete(),a-=1,o=await o.continue()},dt=async(e,t)=>{const r=Ke(e),o=(await u([b],{mode:"readwrite"})).transaction(b,"readwrite"),a=o.objectStore(b);await a.put(r);const s=(t==null?void 0:t.maxEntries)??ae;return await Ne(a,s),await o.done,r},ut=async e=>{const r=(await u([b],{mode:"readonly"})).transaction(b,"readonly"),o=r.objectStore(b).index("by_created_at"),a=(e==null?void 0:e.limit)??ae,s=[];for(let i=await o.openCursor(void 0,"prev");i&&s.length<a;i=await i.continue()){const c=i.value;(!(e!=null&&e.kind)||c.kind===e.kind)&&s.push(c)}return await r.done,s};export{dt as appendAuditLogEntry,it as clearCardResults,ct as ensureColumnStoreRecord,ie as ensureDatasetRuntimeConfig,Xe as persistCleanDataset,rt as readAllRows,ut as readAuditLogEntries,Qe as readCardResults,et as readColumnProfiles,ce as readColumnStoreRecord,Fe as readDatasetRuntimeConfig,st as readMemorySnapshots,ot as readPreparationLog,Ze as readProvenance,Ue as readSampledRows,nt as replacePreparationLog,Je as saveCardResult,at as saveMemorySnapshot,tt as updateDatasetRuntimeConfig};

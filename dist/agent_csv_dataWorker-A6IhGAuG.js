const A=r=>{if(r==null)return null;let e=String(r).trim();if(e==="")return null;let n=!1;e.startsWith("(")&&e.endsWith(")")&&(e=e.substring(1,e.length-1),n=!0),e=e.replace(/[$\s€£¥%]/g,"");const s=e.lastIndexOf(","),o=e.lastIndexOf(".");s>o?e=e.replace(/\./g,"").replace(",","."):e=e.replace(/,/g,"");const t=parseFloat(e);return isNaN(t)?null:n?-t:t},k=r=>{if(!r||r.length===0)return[];const e=Object.keys(r[0]),n=[];for(const s of e){let o=!0;const t=r.map(a=>a[s]);let l=0;const u=r.length,d=t.filter(a=>a!==null&&String(a).trim()!=="").length;for(const a of t){const g=A(a);if(a!==null&&String(a).trim()!==""){if(g===null){o=!1;break}l++}}if(o&&l>0){const a=t.map(A).filter(I=>I!==null),g=u>0?a.length/u:0;n.push({name:s,type:"numerical",valueRange:[Math.min(...a),Math.max(...a)],missingPercentage:(1-g)*100,sampleSize:u,nonNullCount:d,numericSampleCount:a.length,numericSampleRatio:g})}else{const a=new Set(t.map(String));n.push({name:s,type:"categorical",uniqueValues:a.size,missingPercentage:u===0?0:t.filter(g=>g===null||String(g).trim()==="").length/u*100,sampleSize:u,nonNullCount:d})}}return n},R="COLUMN_METADATA_MISSING";const L=()=>{throw Object.assign(new Error(R),{code:R})},D=r=>{let e=0;for(let n=0;n<r.length;n++)e=(e<<5)-e+r.charCodeAt(n),e|=0;return Math.abs(e).toString(36)},b=r=>r==null?"":typeof r=="string"?r.trim():String(r),F=(r,e,n=3)=>{const s=[];for(const o of r){const t=o[e];if(t==null||t==="")continue;const l=b(t);if(l&&(s.includes(l)||s.push(l),s.length>=n))break}return s},v=async(r,e)=>{const{datasetId:n,sampleSize:s=2e3}=e;if(!n)throw new Error("datasetId is required for profiling.");const[o,t]=await Promise.all([r.readColumnStoreRecord(n),r.readSampledRows(n,s)]);if(o||L(),t.length===0)throw new Error("No rows available to profile.");const u=k(t).map(a=>({name:a.name,type:a.type,distinct:a.uniqueValues??new Set(t.map(g=>g[a.name])).size,emptyPercentage:a.missingPercentage??0,examples:F(t,a.name)})),d=[];return o.rowCount>t.length&&d.push(`Profiled ${t.length.toLocaleString()} rows (sample) out of ${o.rowCount.toLocaleString()}.`),{rowCount:o.rowCount,sampledRows:t.length,columns:u,warnings:d}},y=(r,e)=>!e||e.length===0?!0:e.every(n=>{const s=r[n.column],o=b(s),t=b(n.value??"");switch(n.op){case"eq":return n.caseInsensitive?o.toLowerCase()===t.toLowerCase():o===t;case"neq":return n.caseInsensitive?o.toLowerCase()!==t.toLowerCase():o!==t;case"gt":return Number(o)>Number(t);case"gte":return Number(o)>=Number(t);case"lt":return Number(o)<Number(t);case"lte":return Number(o)<=Number(t);case"contains":return o.toLowerCase().includes(t.toLowerCase());case"in":return Array.isArray(n.values)?n.values.some(l=>b(l)===o):!1;default:return!0}}),T=(r,e,n)=>{var M;const s=e.mode??"sample";if(!Array.isArray(e.metrics)||e.metrics.length===0)throw new Error("metrics[] is required for aggregation.");if(s==="full"&&!e.allowFullScan)throw new Error("FULL_SCAN_BLOCKED");const o=e.by??[],t=new Map,l=((M=e.filter)==null?void 0:M.length)??0,u=(typeof performance<"u"?performance.now():Date.now())+3e3;for(const m of r){if(!y(m,e.filter))continue;if((typeof performance<"u"?performance.now():Date.now())>u){if(s==="full")throw new Error("AGG_TIMEOUT");break}const w=o.map(i=>b(m[i])),h=w.length>0?w.join("||"):"__total__";if(!t.has(h)){const i={};o.forEach((f,p)=>{i[f]=w[p]});const E={};e.metrics.forEach(f=>{const p=f.as??`${f.fn}_${f.column??"rows"}`;E[p]={sum:0,count:0,min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}),t.set(h,{keys:i,accumulators:E})}const c=t.get(h);e.metrics.forEach(i=>{const E=i.as??`${i.fn}_${i.column??"rows"}`,f=c.accumulators[E];if(i.fn==="count"){f.count+=1,f.sum+=1;return}if(!i.column)throw new Error(`Metric ${i.fn} requires a column.`);const p=A(m[i.column]);p!==null&&(f.count+=1,f.sum+=p,f.min=Math.min(f.min,p),f.max=Math.max(f.max,p))})}const d=[...o.map(m=>({name:m,type:"string"})),...e.metrics.map(m=>({name:m.as??`${m.fn}_${m.column??"rows"}`,type:"number"}))],a=[];for(const m of t.values()){const S={...m.keys};e.metrics.forEach(w=>{const h=w.as??`${w.fn}_${w.column??"rows"}`,c=m.accumulators[h];let i=null;switch(w.fn){case"sum":i=c.sum;break;case"avg":i=c.count>0?c.sum/c.count:null;break;case"count":i=c.count;break;case"min":i=c.min===Number.POSITIVE_INFINITY?null:c.min;break;case"max":i=c.max===Number.NEGATIVE_INFINITY?null:c.max;break}S[h]=i??0}),a.push(S)}e.orderBy&&e.orderBy.length>0&&a.sort((m,S)=>{for(const w of e.orderBy){const h=(w.direction??"desc").toLowerCase()==="asc"?1:-1,c=m[w.column],i=S[w.column];if(c===i)continue;if(c==null)return 1;if(i==null)return-1;if(typeof c=="number"&&typeof i=="number")return c>i?h:-h;const E=String(c).localeCompare(String(i));if(E!==0)return E*h}return 0});const g=typeof e.limit=="number"?a.slice(0,e.limit):a,I=r.length,N=s!=="full"&&I<n,C=[];return N&&C.push("Aggregated on sampled rows. Retry with allowFullScan for full coverage."),{schema:d,rows:g,provenance:{datasetId:e.datasetId,sampled:N,mode:s,processedRows:I,totalRows:n,queryHash:D(JSON.stringify({by:o,metrics:e.metrics,filter:e.filter,orderBy:e.orderBy,limit:e.limit,mode:s})),filterCount:l,warnings:C}}},P=async(r,e)=>{const n=await r.readColumnStoreRecord(e.datasetId);n||L();const s=e.mode??"sample",o=s;e.mode=o;const t=e.sampleSize??3e3;try{const l=o==="full"?await r.readAllRows(e.datasetId):await r.readSampledRows(e.datasetId,t);if(l.length===0)throw new Error("No rows available for aggregation.");const u=T(l,e,n.rowCount);return u.provenance.requestedMode=s,u}catch(l){if(l instanceof Error&&l.message==="FULL_SCAN_BLOCKED")throw Object.assign(new Error("Full scan requires confirmation."),{code:"FULL_SCAN_BLOCKED"});if(l instanceof Error&&l.message==="AGG_TIMEOUT"&&o==="full"){const u=await r.readSampledRows(e.datasetId,t),d=T(u,{...e,mode:"sample"},n.rowCount);return d.provenance.warnings.push("Full scan timed out. Showing sampled results."),d.provenance.requestedMode=s,d.provenance.downgradedFrom=s,d.provenance.downgradeReason="timeout",d}throw l}},O=async(r,e)=>{const{datasetId:n,n:s=1e3,withColumns:o=!1}=e;if(!n)throw new Error("datasetId is required for sampling.");const[t,l]=await Promise.all([r.readSampledRows(n,s),o?r.readColumnStoreRecord(n):Promise.resolve(null)]);if(o&&!l&&L(),t.length===0)throw new Error("No rows available to sample.");return{rows:t,sampled:!0,columns:l==null?void 0:l.columns}};let _=null;const x=()=>typeof indexedDB<"u"&&"IDBDatabase"in self,U=async()=>{if(!x())throw new Error("IndexedDB is not available inside the worker context.");return _||(_=import("./agent_csv_csvAgentDb-CDC2CtGB.js")),_},B=async()=>{const r=await U();return{readColumnStoreRecord:r.readColumnStoreRecord,readSampledRows:r.readSampledRows,readAllRows:r.readAllRows}},$=async r=>{const e=performance.now();try{let n;const s=await B();switch(r.action){case"profile":n=await v(s,r.payload);break;case"sample":n=await O(s,r.payload);break;case"aggregate":n=await P(s,r.payload);break;default:throw new Error(`Unknown action: ${r.action}`)}return{id:r.id,ok:!0,result:n,durationMs:performance.now()-e}}catch(n){const s=n instanceof Error?n.message:"Unknown worker error";let o;return n instanceof Error&&n.code==="FULL_SCAN_BLOCKED"?o="Please confirm full scan with the user, then retry with allowFullScan=true.":s.includes("IndexedDB")?o="Browser blocked IndexedDB in this worker; falling back to main thread.":o="Retry with a smaller sample or adjust your query.",{id:r.id,ok:!1,reason:s,hint:o,durationMs:performance.now()-e}}};self.addEventListener("message",r=>{const e=r.data;!e||typeof e.id!="string"||$(e).then(n=>{self.postMessage(n)})});export{k as p};

import{c as we,m as fe,h as ye,p as me,s as ge}from"./agent_csv_dataWorker-sxes9h5U.js";const j=(e,t)=>t.some(r=>e instanceof r);let z,N;function he(){return z||(z=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function be(){return N||(N=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const k=new WeakMap,P=new WeakMap,A=new WeakMap;function Se(e){const t=new Promise((r,n)=>{const o=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{r(D(e.result)),o()},s=()=>{n(e.error),o()};e.addEventListener("success",a),e.addEventListener("error",s)});return A.set(t,e),t}function De(e){if(k.has(e))return;const t=new Promise((r,n)=>{const o=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{r(),o()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),o()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)});k.set(e,t)}let L={get(e,t,r){if(e instanceof IDBTransaction){if(t==="done")return k.get(e);if(t==="store")return r.objectStoreNames[1]?void 0:r.objectStore(r.objectStoreNames[0])}return D(e[t])},set(e,t,r){return e[t]=r,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function te(e){L=e(L)}function pe(e){return be().includes(e)?function(...t){return e.apply(B(this),t),D(this.request)}:function(...t){return D(e.apply(B(this),t))}}function Ie(e){return typeof e=="function"?pe(e):(e instanceof IDBTransaction&&De(e),j(e,he())?new Proxy(e,L):e)}function D(e){if(e instanceof IDBRequest)return Se(e);if(P.has(e))return P.get(e);const t=Ie(e);return t!==e&&(P.set(e,t),A.set(t,e)),t}const B=e=>A.get(e);function re(e,t,{blocked:r,upgrade:n,blocking:o,terminated:a}={}){const s=indexedDB.open(e,t),i=D(s);return n&&s.addEventListener("upgradeneeded",c=>{n(D(s.result),c.oldVersion,c.newVersion,D(s.transaction),c)}),r&&s.addEventListener("blocked",c=>r(c.oldVersion,c.newVersion,c)),i.then(c=>{a&&c.addEventListener("close",()=>a()),o&&c.addEventListener("versionchange",d=>o(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const xe=["get","getKey","getAll","getAllKeys","count"],Ce=["put","add","delete","clear"],T=new Map;function K(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(T.get(t))return T.get(t);const r=t.replace(/FromIndex$/,""),n=t!==r,o=Ce.includes(r);if(!(r in(n?IDBIndex:IDBObjectStore).prototype)||!(o||xe.includes(r)))return;const a=async function(s,...i){const c=this.transaction(s,o?"readwrite":"readonly");let d=c.store;return n&&(d=d.index(i.shift())),(await Promise.all([d[r](...i),o&&c.done]))[0]};return T.set(t,a),a}te(e=>({...e,get:(t,r,n)=>K(t,r)||e.get(t,r,n),has:(t,r)=>!!K(t,r)||e.has(t,r)}));const _e=["continue","continuePrimaryKey","advance"],G={},$=new WeakMap,ne=new WeakMap,ve={get(e,t){if(!_e.includes(t))return e[t];let r=G[t];return r||(r=G[t]=function(...n){$.set(this,ne.get(this)[t](...n))}),r}};async function*Ee(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const r=new Proxy(t,ve);for(ne.set(r,t),A.set(r,B(t));t;)yield r,t=await($.get(r)||t.continue()),$.delete(r)}function Y(e,t){return t===Symbol.asyncIterator&&j(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&j(e,[IDBIndex,IDBObjectStore])}te(e=>({...e,get(t,r,n){return Y(t,r)?Ee:e.get(t,r,n)},has(t,r){return Y(t,r)||e.has(t,r)}}));const q="csv_agent_db",X=5,p="provenance",y="clean_rows",f="columns",w="views",m="preparation_log",g="memory_snapshots",h="dataset_runtime_config",_="system_meta",J="csv_agent_db is in read-only fallback because the last migration failed. Close other tabs or clear site data, then reload.",Ae=32;let S=null,E=null,V=!1,x=null;const C=[],Re=e=>{if(!(e!=null&&e.stringStrategy))return!0;const{caseStrategy:t,trimWhitespace:r,nullReplacement:n}=e.stringStrategy;return typeof r!="boolean"||t!=="as-is"&&t!=="lower"||typeof n!="string"||n.length===0},Oe=async e=>{const t=ye(e??null);return e&&t&&Re(e)&&await H(t),t},R=()=>typeof crypto<"u"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,Me=[{version:1,description:"Initialize core CSV Agent object stores.",up:e=>{[p,y,f,w,m,g,h].forEach(r=>ee(e,r))}},{version:5,description:"Add system meta store for migration logging.",up:e=>{ee(e,_)}}],Pe=e=>{var t;if((t=e==null?void 0:e.db)!=null&&t.objectStoreNames.contains(_))try{const r=e.objectStore(_);for(;C.length>0;){const n=C[0];r.put(n),C.shift()}}catch(r){console.warn("Failed to persist migration log entry.",r)}},Q=(e,t)=>{const r={id:`migration-${t.version}-${R()}`,type:"migration",version:t.version,description:t.description,status:t.status,error:t.error??null,createdAt:new Date().toISOString()};C.push(r),Pe(e)},Te=(e,t,r,n)=>{if(!n)return;const o=Me.filter(a=>a.version>r&&a.version<=n).sort((a,s)=>a.version-s.version);for(const a of o)try{a.up(e,t),Q(t,{version:a.version,description:a.description,status:"succeeded"})}catch(s){throw x=a.version,Q(t,{version:a.version,description:a.description,status:"failed",error:s instanceof Error?s.message:String(s)}),s}},je=(e,t)=>{const r=t.filter(n=>!e.objectStoreNames.contains(n));if(r.length>0)throw new Error(`Missing object stores: ${r.join(", ")}`)},Z=async()=>(E||(E=re(q,void 0,{blocked:()=>console.warn("csv_agent_db read-only open is blocked by another tab.")})),E),oe=async()=>{await new Promise((e,t)=>{const r=indexedDB.deleteDatabase(q);r.onsuccess=()=>e(),r.onerror=()=>t(r.error),r.onblocked=()=>console.warn("IndexedDB delete blocked. Close other tabs to proceed.")}),S=null,E=null,V=!1,x=null,C.length=0},ee=(e,t)=>{if(!e.objectStoreNames.contains(t)){if(t===y){e.createObjectStore(t,{keyPath:"chunkId"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===f){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===w){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===p){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===m){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===g){const r=e.createObjectStore(t,{keyPath:"id"});r.createIndex("by_dataset","datasetId",{unique:!1}),r.createIndex("by_view","viewId",{unique:!1});return}if(t===h){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===_){const r=e.createObjectStore(t,{keyPath:"id"});r.createIndex("by_type","type",{unique:!1}),r.createIndex("by_version","version",{unique:!1});return}throw new Error(`Unsupported store name: ${t}`)}},ke=async e=>{try{return await e()}catch(t){if(t instanceof DOMException&&t.name==="VersionError")return console.warn("IndexedDB version mismatch detected. Resetting csv_agent_db...",t),await oe(),e();throw t}},Le=[p,y,f,w,m,g,h,_],l=async(e=[],t)=>{const r=(t==null?void 0:t.mode)??"readonly",n=Array.from(new Set([...Le,...e]));if(V){if(r==="readwrite")throw new Error(J);return Z()}S||(x=null,S=ke(()=>re(q,X,{upgrade(o,a,s,i){Te(o,i,a,s??X)},blocked:()=>console.warn("csv_agent_db upgrade is blocked by another tab."),blocking:()=>console.warn("csv_agent_db upgrade is blocking existing tabs. Reload others to proceed."),terminated:()=>{S=null}})));try{const o=await S;return je(o,n),o}catch(o){if(x!==null){if(console.error(`csv_agent_db migration to version ${x} failed; entering read-only fallback.`,o),V=!0,S=null,r==="readwrite")throw new Error(J);return Z()}throw S=null,o}},Be=(e,t)=>{const r=[];for(let n=0;n<e.length;n+=t)r.push(e.slice(n,n+t));return r},Ne=async e=>{const{datasetId:t,rows:r,columns:n,provenance:o,chunkSize:a=2e4}=e;if(!t)throw new Error("persistCleanDataset requires datasetId.");const s=async c=>{const u=(await l([y,f,w],{mode:"readwrite"})).transaction([y,f,p],"readwrite"),b=u.objectStore(y),ce=u.objectStore(f),ie=u.objectStore(p),O=Be(r,a),W=new Date().toISOString();try{let v=await b.index("by_dataset").openCursor(t);for(;v;)await v.delete(),v=await v.continue();for(let I=0;I<O.length;I+=1){const M=O[I],le={chunkId:`${t}-chunk-${I}`,datasetId:t,rowCount:M.length,startRow:I*a,endRow:I*a+M.length-1,rows:M,createdAt:W};await b.put(le)}const de={datasetId:t,columnCount:n.length,columns:n,rowCount:r.length,updatedAt:W};await ce.put(de);const ue={datasetId:t,fileName:o.fileName,bytes:o.bytes,checksum:o.checksum,cleanedAt:o.cleanedAt,normalization:ge(c.stringStrategy)};return await ie.put(ue),await u.done,{chunkCount:O.length,rowCount:r.length}}catch(U){try{u.abort()}catch{}throw await u.done.catch(()=>{}),U}},i=async()=>{const c=await se(t,{rowCountHint:r.length});return s(c)};try{return await i()}catch(c){if(c instanceof DOMException&&c.name==="NotFoundError")return console.warn("IndexedDB store missing detected. Resetting and retrying persist...",c),await oe(),i();throw c}},Ke=async e=>{const{datasetId:t,title:r,kind:n,queryHash:o,explainer:a,dataRef:s}=e,c=(await l([w],{mode:"readwrite"})).transaction(w,"readwrite"),d=c.objectStore(w),u=`${t}-view-${R()}`,b={id:u,datasetId:t,title:r,kind:n,queryHash:o,explainer:a,dataRef:s,createdAt:new Date().toISOString()};return await d.put(b),await c.done,u},Ge=async e=>{const t=await l([w]);try{const r=t.transaction(w,"readonly"),a=await r.objectStore(w).index("by_dataset").getAll(e);return await r.done,a}catch(r){return console.warn(`Failed to read card results for ${e}`,r),[]}},Ye=async e=>{const r=(await l()).transaction(p,"readonly"),o=await r.objectStore(p).get(e);return await r.done,o??void 0},ae=async e=>{const r=(await l([f])).transaction(f,"readonly"),o=await r.objectStore(f).get(e);return await r.done,o??null},Xe=async e=>{const t=await ae(e);return(t==null?void 0:t.columns)??null},F=async(e,t)=>{const n=(await l([y])).transaction(y,"readonly"),a=n.objectStore(y).index("by_dataset");let s=!1;const i=()=>{s=!0};let c=await a.openCursor(e);for(;c&&!s;){const d=c.value;if(await t(d,i),s)break;c=await c.continue()}await n.done},$e=async e=>{let t=0;return await F(e,r=>{const n=typeof r.rowCount=="number"?r.rowCount:r.rows.length;t+=n}),t};async function Ve(e){const r=(await l([h])).transaction(h,"readonly"),o=await r.objectStore(h).get(e);return await r.done,Oe(o)}async function H(e){const r=(await l([h],{mode:"readwrite"})).transaction(h,"readwrite");await r.objectStore(h).put(e),await r.done}async function se(e,t){const r=await Ve(e);if(r)return r;const n=we(e,{rowCountHint:t==null?void 0:t.rowCountHint,preferredMode:t==null?void 0:t.preferredMode});return await H(n),n}async function Je(e,t,r){const n=await se(e,{rowCountHint:r==null?void 0:r.rowCountHint}),o=fe(n,t);return await H(o),o}const qe=async(e,t)=>{const r=[];return await F(e,(n,o)=>{for(const a of n.rows)if(r.push(a),r.length>=t){o();break}}),r},Qe=async e=>{const t=[];return await F(e,r=>{t.push(...r.rows)}),t},Fe=(e,t)=>{const r=new Date().toISOString();return t.map((n,o)=>({...n,datasetId:e,id:n.id??`${e}-prep-${R()}`,stepOrder:typeof n.stepOrder=="number"?n.stepOrder:o,scope:n.scope??"dataset",columnName:n.columnName??null,source:n.source??"ai_plan",tags:n.tags??[],createdAt:n.createdAt??r}))},Ze=async(e,t=[])=>{if(!e)throw new Error("replacePreparationLog requires datasetId.");const n=(await l([m],{mode:"readwrite"})).transaction(m,"readwrite"),o=n.objectStore(m);let s=await o.index("by_dataset").openCursor(e);for(;s;)await s.delete(),s=await s.continue();if(t.length>0){const i=Fe(e,t).sort((c,d)=>c.stepOrder-d.stepOrder||new Date(c.createdAt).getTime()-new Date(d.createdAt).getTime());for(const c of i)await o.put(c)}await n.done},et=async e=>{if(!e)return[];const t=await l([m]);try{const r=t.transaction(m,"readonly"),a=await r.objectStore(m).index("by_dataset").getAll(e);return await r.done,a.sort((s,i)=>s.stepOrder-i.stepOrder||new Date(s.createdAt).getTime()-new Date(i.createdAt).getTime())}catch(r){return console.warn(`Failed to read preparation log for ${e}`,r),[]}},He=async(e,t,r=Ae)=>{const n=await e.index("by_dataset").getAll(t);if(n.length<=r)return;const o=n.sort((i,c)=>{const d=(c.qualityScore??0)-(i.qualityScore??0);return d!==0?d:new Date(c.createdAt).getTime()-new Date(i.createdAt).getTime()}).slice(0,r),a=new Set(o.map(i=>i.id)),s=n.filter(i=>!a.has(i.id));for(const i of s)await e.delete(i.id)},tt=async e=>{var a,s;if(!e.datasetId)throw new Error("saveMemorySnapshot requires datasetId.");const r=(await l([g],{mode:"readwrite"})).transaction(g,"readwrite"),n=r.objectStore(g),o={...e,id:e.id??e.viewId??e.cardId??`${e.datasetId}-memo-${R()}`,createdAt:e.createdAt??new Date().toISOString(),plan:e.plan??null,viewId:e.viewId??null,cardId:e.cardId??null,summary:e.summary??"",title:e.title??"Untitled View",sampleRows:e.sampleRows??[],tags:e.tags??[],chartType:e.chartType??((a=e.plan)==null?void 0:a.chartType),queryHash:e.queryHash??null,rowCount:typeof e.rowCount=="number"?e.rowCount:((s=e.sampleRows)==null?void 0:s.length)??0,sampled:e.sampled??!1,expiresAt:e.expiresAt??null};return await n.put(o),await He(n,o.datasetId),await r.done,o.id},rt=async(e,t)=>{if(!e)return[];const r=await l([g]);try{const n=r.transaction(g,"readonly"),s=await n.objectStore(g).index("by_dataset").getAll(e);await n.done;const i=s.filter(d=>t!=null&&t.minScore?(d.qualityScore??0)>=t.minScore:!0).filter(d=>{var u;return t!=null&&t.tag?(u=d.tags)==null?void 0:u.includes(t.tag):!0}).sort((d,u)=>{const b=(u.qualityScore??0)-(d.qualityScore??0);return b!==0?b:new Date(u.createdAt).getTime()-new Date(d.createdAt).getTime()}),c=(t==null?void 0:t.limit)??i.length;return i.slice(0,c)}catch(n){return console.warn(`Failed to read memory snapshots for ${e}`,n),[]}},We=2e3,Ue=async e=>{try{const[t,r]=await Promise.all([qe(e,We),$e(e)]);if(r===0||t.length===0)return console.warn(`CSV Agent: unable to rebuild column metadata for ${e} because the dataset has no cached rows.`),null;const n=me(t),o={datasetId:e,columnCount:n.length,columns:n,rowCount:r,updatedAt:new Date().toISOString()},s=(await l([f],{mode:"readwrite"})).transaction(f,"readwrite");return await s.objectStore(f).put(o),await s.done,console.info(`CSV Agent: rebuilt missing column metadata for dataset ${e}.`),o}catch(t){return console.error(`CSV Agent: failed to rebuild column metadata for dataset ${e}.`,t),null}},nt=async e=>{const t=await ae(e);return t||Ue(e)},ot=async e=>{const r=(await l([w],{mode:"readwrite"})).transaction(w,"readwrite");let a=await r.objectStore(w).index("by_dataset").openCursor(e);for(;a;)await a.delete(),a=await a.continue();await r.done};export{ot as clearCardResults,nt as ensureColumnStoreRecord,se as ensureDatasetRuntimeConfig,Ne as persistCleanDataset,Qe as readAllRows,Ge as readCardResults,Xe as readColumnProfiles,ae as readColumnStoreRecord,Ve as readDatasetRuntimeConfig,rt as readMemorySnapshots,et as readPreparationLog,Ye as readProvenance,qe as readSampledRows,Ze as replacePreparationLog,Ke as saveCardResult,tt as saveMemorySnapshot,Je as updateDatasetRuntimeConfig};

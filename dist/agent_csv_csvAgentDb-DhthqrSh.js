const C=(e,t)=>t.some(n=>e instanceof n);let R,j;function q(){return R||(R=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function H(){return j||(j=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const B=new WeakMap,E=new WeakMap,D=new WeakMap;function z(e){const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("success",o),e.removeEventListener("error",a)},o=()=>{n(h(e.result)),s()},a=()=>{r(e.error),s()};e.addEventListener("success",o),e.addEventListener("error",a)});return D.set(t,e),t}function G(e){if(B.has(e))return;const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("complete",o),e.removeEventListener("error",a),e.removeEventListener("abort",a)},o=()=>{n(),s()},a=()=>{r(e.error||new DOMException("AbortError","AbortError")),s()};e.addEventListener("complete",o),e.addEventListener("error",a),e.addEventListener("abort",a)});B.set(e,t)}let P={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return B.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return h(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function T(e){P=e(P)}function J(e){return H().includes(e)?function(...t){return e.apply(k(this),t),h(this.request)}:function(...t){return h(e.apply(k(this),t))}}function Q(e){return typeof e=="function"?J(e):(e instanceof IDBTransaction&&G(e),C(e,q())?new Proxy(e,P):e)}function h(e){if(e instanceof IDBRequest)return z(e);if(E.has(e))return E.get(e);const t=Q(e);return t!==e&&(E.set(e,t),D.set(t,e)),t}const k=e=>D.get(e);function X(e,t,{blocked:n,upgrade:r,blocking:s,terminated:o}={}){const a=indexedDB.open(e,t),i=h(a);return r&&a.addEventListener("upgradeneeded",c=>{r(h(a.result),c.oldVersion,c.newVersion,h(a.transaction),c)}),n&&a.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),i.then(c=>{o&&c.addEventListener("close",()=>o()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const Y=["get","getKey","getAll","getAllKeys","count"],Z=["put","add","delete","clear"],x=new Map;function M(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(x.get(t))return x.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=Z.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||Y.includes(n)))return;const o=async function(a,...i){const c=this.transaction(a,s?"readwrite":"readonly");let d=c.store;return r&&(d=d.index(i.shift())),(await Promise.all([d[n](...i),s&&c.done]))[0]};return x.set(t,o),o}T(e=>({...e,get:(t,n,r)=>M(t,n)||e.get(t,n,r),has:(t,n)=>!!M(t,n)||e.has(t,n)}));const tt=["continue","continuePrimaryKey","advance"],A={},O=new WeakMap,V=new WeakMap,et={get(e,t){if(!tt.includes(t))return e[t];let n=A[t];return n||(n=A[t]=function(...r){O.set(this,V.get(this)[t](...r))}),n}};async function*nt(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,et);for(V.set(n,t),D.set(n,k(t));t;)yield n,t=await(O.get(n)||t.continue()),O.delete(n)}function _(e,t){return t===Symbol.asyncIterator&&C(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&C(e,[IDBIndex,IDBObjectStore])}T(e=>({...e,get(t,n,r){return _(t,n)?nt:e.get(t,n,r)},has(t,n){return _(t,n)||e.has(t,n)}}));const W="csv_agent_db",rt=3,I="provenance",l="clean_rows",w="columns",u="views";let f=null;const $=async()=>{await new Promise((e,t)=>{const n=indexedDB.deleteDatabase(W);n.onsuccess=()=>e(),n.onerror=()=>t(n.error),n.onblocked=()=>console.warn("IndexedDB delete blocked. Close other tabs to proceed.")}),f=null},ot=(e,t)=>{if(!e.objectStoreNames.contains(t)){if(t===l){e.createObjectStore(t,{keyPath:"chunkId"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===w){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===u){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===I){e.createObjectStore(t,{keyPath:"datasetId"});return}throw new Error(`Unsupported store name: ${t}`)}},L=async e=>{try{return await e()}catch(t){if(t instanceof DOMException&&t.name==="VersionError")return console.warn("IndexedDB version mismatch detected. Resetting csv_agent_db...",t),await $(),e();throw t}},st=[I,l,w,u],y=async(e=[])=>{const t=Array.from(new Set([...st,...e])),n=(a,i)=>X(W,a,{upgrade(c){i.forEach(d=>ot(c,d))}});if(!f)return f=L(()=>n(rt,t)),f;const r=await f;if(t.filter(a=>!r.objectStoreNames.contains(a)).length===0)return r;r.close();const o=r.version+1;return f=L(()=>n(o,t)),f},at=(e,t)=>{const n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t));return n},it=async e=>{const{datasetId:t,rows:n,columns:r,provenance:s,chunkSize:o=2e4}=e;if(!t)throw new Error("persistCleanDataset requires datasetId.");const a=async()=>{const c=(await y([l,w,u])).transaction([l,w,I],"readwrite"),d=c.objectStore(l),g=c.objectStore(w),m=c.objectStore(I);await d.clear();const S=at(n,o),v=new Date().toISOString();for(let b=0;b<S.length;b+=1){const p=S[b],K={chunkId:`${t}-chunk-${b}`,datasetId:t,rowCount:p.length,startRow:b*o,endRow:b*o+p.length-1,rows:p,createdAt:v};await d.put(K)}const U={datasetId:t,columnCount:r.length,columns:r,rowCount:n.length,updatedAt:v};await g.put(U);const N={datasetId:t,fileName:s.fileName,bytes:s.bytes,checksum:s.checksum,cleanedAt:s.cleanedAt};return await m.put(N),await c.done,{chunkCount:S.length,rowCount:n.length}};try{return await a()}catch(i){if(i instanceof DOMException&&i.name==="NotFoundError")return console.warn("IndexedDB store missing detected. Resetting and retrying persist...",i),await $(),a();throw i}},dt=async e=>{const{datasetId:t,title:n,kind:r,queryHash:s,explainer:o,dataRef:a}=e,c=(await y([u])).transaction(u,"readwrite"),d=c.objectStore(u),g=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,m=`${t}-view-${g}`,S={id:m,datasetId:t,title:n,kind:r,queryHash:s,explainer:o,dataRef:a,createdAt:new Date().toISOString()};return await d.put(S),await c.done,m},ut=async e=>{const t=await y([u]);try{const n=t.transaction(u,"readonly"),o=await n.objectStore(u).index("by_dataset").getAll(e);return await n.done,o}catch(n){return console.warn(`Failed to read card results for ${e}`,n),[]}},lt=async e=>{const n=(await y()).transaction(I,"readonly"),s=await n.objectStore(I).get(e);return await n.done,s??void 0},ct=async e=>{const n=(await y([w])).transaction(w,"readonly"),s=await n.objectStore(w).get(e);return await n.done,s??null},wt=async e=>{const t=await ct(e);return(t==null?void 0:t.columns)??null},F=async(e,t)=>{const r=(await y([l])).transaction(l,"readonly"),o=r.objectStore(l).index("by_dataset");let a=!1;const i=()=>{a=!0};let c=await o.openCursor(e);for(;c&&!a;){const d=c.value;if(await t(d,i),a)break;c=await c.continue()}await r.done},ft=async(e,t)=>{const n=[];return await F(e,(r,s)=>{for(const o of r.rows)if(n.push(o),n.length>=t){s();break}}),n},ht=async e=>{const t=[];return await F(e,n=>{t.push(...n.rows)}),t},yt=async e=>{const n=(await y([u])).transaction(u,"readwrite");let o=await n.objectStore(u).index("by_dataset").openCursor(e);for(;o;)await o.delete(),o=await o.continue();await n.done};export{yt as clearCardResults,it as persistCleanDataset,ht as readAllRows,ut as readCardResults,wt as readColumnProfiles,ct as readColumnStoreRecord,lt as readProvenance,ft as readSampledRows,dt as saveCardResult};

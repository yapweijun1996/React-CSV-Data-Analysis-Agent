import{p as J}from"./agent_csv_dataWorker-CnjjBSpR.js";const P=(e,t)=>t.some(n=>e instanceof n);let k,V;function Q(){return k||(k=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Z(){return V||(V=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const R=new WeakMap,C=new WeakMap,p=new WeakMap;function ee(e){const t=new Promise((n,r)=>{const a=()=>{e.removeEventListener("success",s),e.removeEventListener("error",o)},s=()=>{n(b(e.result)),a()},o=()=>{r(e.error),a()};e.addEventListener("success",s),e.addEventListener("error",o)});return p.set(t,e),t}function te(e){if(R.has(e))return;const t=new Promise((n,r)=>{const a=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",o),e.removeEventListener("abort",o)},s=()=>{n(),a()},o=()=>{r(e.error||new DOMException("AbortError","AbortError")),a()};e.addEventListener("complete",s),e.addEventListener("error",o),e.addEventListener("abort",o)});R.set(e,t)}let _={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return R.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return b(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function U(e){_=e(_)}function ne(e){return Z().includes(e)?function(...t){return e.apply(v(this),t),b(this.request)}:function(...t){return b(e.apply(v(this),t))}}function re(e){return typeof e=="function"?ne(e):(e instanceof IDBTransaction&&te(e),P(e,Q())?new Proxy(e,_):e)}function b(e){if(e instanceof IDBRequest)return ee(e);if(C.has(e))return C.get(e);const t=re(e);return t!==e&&(C.set(e,t),p.set(t,e)),t}const v=e=>p.get(e);function oe(e,t,{blocked:n,upgrade:r,blocking:a,terminated:s}={}){const o=indexedDB.open(e,t),i=b(o);return r&&o.addEventListener("upgradeneeded",c=>{r(b(o.result),c.oldVersion,c.newVersion,b(o.transaction),c)}),n&&o.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),i.then(c=>{s&&c.addEventListener("close",()=>s()),a&&c.addEventListener("versionchange",d=>a(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const ae=["get","getKey","getAll","getAllKeys","count"],se=["put","add","delete","clear"],O=new Map;function $(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(O.get(t))return O.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,a=se.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(a||ae.includes(n)))return;const s=async function(o,...i){const c=this.transaction(o,a?"readwrite":"readonly");let d=c.store;return r&&(d=d.index(i.shift())),(await Promise.all([d[n](...i),a&&c.done]))[0]};return O.set(t,s),s}U(e=>({...e,get:(t,n,r)=>$(t,n)||e.get(t,n,r),has:(t,n)=>!!$(t,n)||e.has(t,n)}));const ce=["continue","continuePrimaryKey","advance"],q={},T=new WeakMap,N=new WeakMap,ie={get(e,t){if(!ce.includes(t))return e[t];let n=q[t];return n||(n=q[t]=function(...r){T.set(this,N.get(this)[t](...r))}),n}};async function*de(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,ie);for(N.set(n,t),p.set(n,v(t));t;)yield n,t=await(T.get(n)||t.continue()),T.delete(n)}function F(e,t){return t===Symbol.asyncIterator&&P(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&P(e,[IDBIndex,IDBObjectStore])}U(e=>({...e,get(t,n,r){return F(t,n)?de:e.get(t,n,r)},has(t,n){return F(t,n)||e.has(t,n)}}));const H="csv_agent_db",ue=3,D="provenance",h="clean_rows",w="columns",u="views",y="preparation_log",m="memory_snapshots",le=32;let S=null;const M=()=>typeof crypto<"u"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():`${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`,K=async()=>{await new Promise((e,t)=>{const n=indexedDB.deleteDatabase(H);n.onsuccess=()=>e(),n.onerror=()=>t(n.error),n.onblocked=()=>console.warn("IndexedDB delete blocked. Close other tabs to proceed.")}),S=null},we=(e,t)=>{if(!e.objectStoreNames.contains(t)){if(t===h){e.createObjectStore(t,{keyPath:"chunkId"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===w){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===u){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===D){e.createObjectStore(t,{keyPath:"datasetId"});return}if(t===y){e.createObjectStore(t,{keyPath:"id"}).createIndex("by_dataset","datasetId",{unique:!1});return}if(t===m){const n=e.createObjectStore(t,{keyPath:"id"});n.createIndex("by_dataset","datasetId",{unique:!1}),n.createIndex("by_view","viewId",{unique:!1});return}throw new Error(`Unsupported store name: ${t}`)}},W=async e=>{try{return await e()}catch(t){if(t instanceof DOMException&&t.name==="VersionError")return console.warn("IndexedDB version mismatch detected. Resetting csv_agent_db...",t),await K(),e();throw t}},fe=[D,h,w,u,y,m],l=async(e=[])=>{const t=Array.from(new Set([...fe,...e])),n=(o,i)=>oe(H,o,{upgrade(c){i.forEach(d=>we(c,d))}});if(!S)return S=W(()=>n(ue,t)),S;const r=await S;if(t.filter(o=>!r.objectStoreNames.contains(o)).length===0)return r;r.close();const s=r.version+1;return S=W(()=>n(s,t)),S},he=(e,t)=>{const n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t));return n},Ie=async e=>{const{datasetId:t,rows:n,columns:r,provenance:a,chunkSize:s=2e4}=e;if(!t)throw new Error("persistCleanDataset requires datasetId.");const o=async()=>{const c=(await l([h,w,u])).transaction([h,w,D],"readwrite"),d=c.objectStore(h),f=c.objectStore(w),g=c.objectStore(D),A=he(n,s),j=new Date().toISOString();try{let I=await d.index("by_dataset").openCursor(t);for(;I;)await I.delete(),I=await I.continue();for(let x=0;x<A.length;x+=1){const E=A[x],X={chunkId:`${t}-chunk-${x}`,datasetId:t,rowCount:E.length,startRow:x*s,endRow:x*s+E.length-1,rows:E,createdAt:j};await d.put(X)}const Y={datasetId:t,columnCount:r.length,columns:r,rowCount:n.length,updatedAt:j};await f.put(Y);const G={datasetId:t,fileName:a.fileName,bytes:a.bytes,checksum:a.checksum,cleanedAt:a.cleanedAt};return await g.put(G),await c.done,{chunkCount:A.length,rowCount:n.length}}catch(L){try{c.abort()}catch{}throw await c.done.catch(()=>{}),L}};try{return await o()}catch(i){if(i instanceof DOMException&&i.name==="NotFoundError")return console.warn("IndexedDB store missing detected. Resetting and retrying persist...",i),await K(),o();throw i}},pe=async e=>{const{datasetId:t,title:n,kind:r,queryHash:a,explainer:s,dataRef:o}=e,c=(await l([u])).transaction(u,"readwrite"),d=c.objectStore(u),f=`${t}-view-${M()}`,g={id:f,datasetId:t,title:n,kind:r,queryHash:a,explainer:s,dataRef:o,createdAt:new Date().toISOString()};return await d.put(g),await c.done,f},Ae=async e=>{const t=await l([u]);try{const n=t.transaction(u,"readonly"),s=await n.objectStore(u).index("by_dataset").getAll(e);return await n.done,s}catch(n){return console.warn(`Failed to read card results for ${e}`,n),[]}},Ee=async e=>{const n=(await l()).transaction(D,"readonly"),a=await n.objectStore(D).get(e);return await n.done,a??void 0},z=async e=>{const n=(await l([w])).transaction(w,"readonly"),a=await n.objectStore(w).get(e);return await n.done,a??null},Ce=async e=>{const t=await z(e);return(t==null?void 0:t.columns)??null},B=async(e,t)=>{const r=(await l([h])).transaction(h,"readonly"),s=r.objectStore(h).index("by_dataset");let o=!1;const i=()=>{o=!0};let c=await s.openCursor(e);for(;c&&!o;){const d=c.value;if(await t(d,i),o)break;c=await c.continue()}await r.done},ye=async e=>{let t=0;return await B(e,n=>{const r=typeof n.rowCount=="number"?n.rowCount:n.rows.length;t+=r}),t},me=async(e,t)=>{const n=[];return await B(e,(r,a)=>{for(const s of r.rows)if(n.push(s),n.length>=t){a();break}}),n},Oe=async e=>{const t=[];return await B(e,n=>{t.push(...n.rows)}),t},Se=(e,t)=>{const n=new Date().toISOString();return t.map((r,a)=>({...r,datasetId:e,id:r.id??`${e}-prep-${M()}`,stepOrder:typeof r.stepOrder=="number"?r.stepOrder:a,scope:r.scope??"dataset",columnName:r.columnName??null,source:r.source??"ai_plan",tags:r.tags??[],createdAt:r.createdAt??n}))},Pe=async(e,t=[])=>{if(!e)throw new Error("replacePreparationLog requires datasetId.");const r=(await l([y])).transaction(y,"readwrite"),a=r.objectStore(y);let o=await a.index("by_dataset").openCursor(e);for(;o;)await o.delete(),o=await o.continue();if(t.length>0){const i=Se(e,t).sort((c,d)=>c.stepOrder-d.stepOrder||new Date(c.createdAt).getTime()-new Date(d.createdAt).getTime());for(const c of i)await a.put(c)}await r.done},Re=async e=>{if(!e)return[];const t=await l([y]);try{const n=t.transaction(y,"readonly"),s=await n.objectStore(y).index("by_dataset").getAll(e);return await n.done,s.sort((o,i)=>o.stepOrder-i.stepOrder||new Date(o.createdAt).getTime()-new Date(i.createdAt).getTime())}catch(n){return console.warn(`Failed to read preparation log for ${e}`,n),[]}},be=async(e,t,n=le)=>{const r=await e.index("by_dataset").getAll(t);if(r.length<=n)return;const a=r.sort((i,c)=>{const d=(c.qualityScore??0)-(i.qualityScore??0);return d!==0?d:new Date(c.createdAt).getTime()-new Date(i.createdAt).getTime()}).slice(0,n),s=new Set(a.map(i=>i.id)),o=r.filter(i=>!s.has(i.id));for(const i of o)await e.delete(i.id)},_e=async e=>{var s,o;if(!e.datasetId)throw new Error("saveMemorySnapshot requires datasetId.");const n=(await l([m])).transaction(m,"readwrite"),r=n.objectStore(m),a={...e,id:e.id??e.viewId??e.cardId??`${e.datasetId}-memo-${M()}`,createdAt:e.createdAt??new Date().toISOString(),plan:e.plan??null,viewId:e.viewId??null,cardId:e.cardId??null,summary:e.summary??"",title:e.title??"Untitled View",sampleRows:e.sampleRows??[],tags:e.tags??[],chartType:e.chartType??((s=e.plan)==null?void 0:s.chartType),queryHash:e.queryHash??null,rowCount:typeof e.rowCount=="number"?e.rowCount:((o=e.sampleRows)==null?void 0:o.length)??0,sampled:e.sampled??!1,expiresAt:e.expiresAt??null};return await r.put(a),await be(r,a.datasetId),await n.done,a.id},ve=async(e,t)=>{if(!e)return[];const n=await l([m]);try{const r=n.transaction(m,"readonly"),o=await r.objectStore(m).index("by_dataset").getAll(e);await r.done;const i=o.filter(d=>t!=null&&t.minScore?(d.qualityScore??0)>=t.minScore:!0).filter(d=>{var f;return t!=null&&t.tag?(f=d.tags)==null?void 0:f.includes(t.tag):!0}).sort((d,f)=>{const g=(f.qualityScore??0)-(d.qualityScore??0);return g!==0?g:new Date(f.createdAt).getTime()-new Date(d.createdAt).getTime()}),c=(t==null?void 0:t.limit)??i.length;return i.slice(0,c)}catch(r){return console.warn(`Failed to read memory snapshots for ${e}`,r),[]}},ge=2e3,xe=async e=>{try{const[t,n]=await Promise.all([me(e,ge),ye(e)]);if(n===0||t.length===0)return console.warn(`CSV Agent: unable to rebuild column metadata for ${e} because the dataset has no cached rows.`),null;const r=J(t),a={datasetId:e,columnCount:r.length,columns:r,rowCount:n,updatedAt:new Date().toISOString()},o=(await l([w])).transaction(w,"readwrite");return await o.objectStore(w).put(a),await o.done,console.info(`CSV Agent: rebuilt missing column metadata for dataset ${e}.`),a}catch(t){return console.error(`CSV Agent: failed to rebuild column metadata for dataset ${e}.`,t),null}},Te=async e=>{const t=await z(e);return t||xe(e)},Me=async e=>{const n=(await l([u])).transaction(u,"readwrite");let s=await n.objectStore(u).index("by_dataset").openCursor(e);for(;s;)await s.delete(),s=await s.continue();await n.done};export{Me as clearCardResults,Te as ensureColumnStoreRecord,Ie as persistCleanDataset,Oe as readAllRows,Ae as readCardResults,Ce as readColumnProfiles,z as readColumnStoreRecord,ve as readMemorySnapshots,Re as readPreparationLog,Ee as readProvenance,me as readSampledRows,Pe as replacePreparationLog,pe as saveCardResult,_e as saveMemorySnapshot};

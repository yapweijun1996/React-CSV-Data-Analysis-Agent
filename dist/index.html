<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Data Analysis Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#2563eb', // A slightly brighter blue for light mode
              'brand-secondary': '#3b82f6',
            },
            animation: {
                'loading-shimmer': 'loading-shimmer 2s infinite linear',
            },
            keyframes: {
                'loading-shimmer': {
                    '0%': { 'background-position': '-200% 0' },
                    '100%': { 'background-position': '200% 0' },
                }
            }
          },
        },
      }
    </script>
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <!-- Papaparse for CSV parsing -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- html-to-image for exporting -->
    <script src="https://unpkg.com/html-to-image@1.11.11/dist/html-to-image.js"></script>

  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.28.0",
    "idb": "https://aistudiocdn.com/idb@^8.0.3",
    "zustand": "https://aistudiocdn.com/zustand@^4.5.4",
    "openai": "https://aistudiocdn.com/openai@^4.52.7"
  }
}
</script>
    <script type="module" crossorigin src="/agent_csv_index-CepyLTzt.js"></script>
  </head>
  <body class="bg-slate-50 text-slate-800">
    <div id="root"></div>
    <script>
      // Engineer presets: edit values below to bake in defaults for every user session.
      window.tempgeminiapikey = window.tempgeminiapikey ?? ''; // e.g. 'AIza...'
      window.tempopenaiapikey = window.tempopenaiapikey ?? ''; // e.g. 'sk-...'
      window.__CSV_AGENT_DEFAULTS__ = {
        defaultSettings: {
          provider: 'google', // 'google' | 'openai'
          model: 'gemini-2.5-flash',
          language: 'Mandarin', // 'English' | 'Mandarin' | 'Spanish' | 'Japanese' | 'French'
          geminiApiKey: window.tempgeminiapikey,
          openAIApiKey: window.tempopenaiapikey,
        },
        ui: {
          showNewButton: false, // false hides the "New" session button
          showSettingsButton: true, // false hides the gear icon in Assistant panel
        },
      };
    </script>
    <script>
      (function () {
        const TARGET_ORIGIN = window.location.origin;
        const DEV_HOSTNAMES = new Set(['localhost', '127.0.0.1', '::1']);
        const isDevEnvironment = DEV_HOSTNAMES.has(window.location.hostname) || window.location.protocol === 'file:';
        const configuredOrigins = Array.isArray(window.CSV_AGENT_ALLOWED_ORIGINS)
          ? window.CSV_AGENT_ALLOWED_ORIGINS
          : [];
        const normalizedConfiguredOrigins = Array.from(
          new Set(
            configuredOrigins
              .map((origin) => {
                if (typeof origin !== 'string' || !origin.trim()) return null;
                try {
                  return new URL(origin.trim(), window.location.href).origin;
                } catch (error) {
                  console.warn('Ignoring invalid origin in CSV_AGENT_ALLOWED_ORIGINS:', origin, error);
                  return null;
                }
              })
              .filter((origin) => typeof origin === 'string'),
          ),
        );
        const crossOriginAllowList = normalizedConfiguredOrigins.filter((origin) => origin !== TARGET_ORIGIN);
        const messageTargetOrigins = Array.from(new Set([TARGET_ORIGIN, ...crossOriginAllowList]));
        const PENDING_PAYLOAD_PREFIX = '__CSV_AGENT_PENDING_PAYLOAD__';
        const PENDING_PAYLOAD_QUERY_PARAM = 'pendingPayloadKey';
        const PENDING_PAYLOAD_MAX_AGE_MS = 5 * 60 * 1000;

        const isOriginAllowed = (origin) => {
          if (!origin) return false;
          if (origin === TARGET_ORIGIN) return true;
          if (isDevEnvironment) {
            return false;
          }
          return crossOriginAllowList.includes(origin);
        };

        const queue = [];
        window.__CSV_AGENT_PENDING_NOTICES__ = Array.isArray(window.__CSV_AGENT_PENDING_NOTICES__)
          ? window.__CSV_AGENT_PENDING_NOTICES__
          : [];

        function pushPendingNotice(message) {
          if (typeof message !== 'string' || !message.trim()) return;
          try {
            if (!Array.isArray(window.__CSV_AGENT_PENDING_NOTICES__)) {
              window.__CSV_AGENT_PENDING_NOTICES__ = [];
            }
            window.__CSV_AGENT_PENDING_NOTICES__.push(message);
            window.dispatchEvent(new CustomEvent('ai-table-csv-notice', { detail: { message } }));
          } catch (error) {
            console.warn('CSV Agent: unable to push pending payload notice.', error);
          }
        }

        function sanitizeFileStem(rawHeader) {
          if (!rawHeader) return 'report';
          const firstLine = rawHeader
            .split(/\r?\n/)
            .map((line) => line.trim())
            .find(Boolean);
          if (!firstLine) return 'report';
          return firstLine
            .replace(/[^a-z0-9-_]+/gi, '-')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '')
            .slice(0, 60) || 'report';
        }

        function enqueuePayload(payload) {
          queue.push(payload);
          window.dispatchEvent(new CustomEvent('ai-table-csv', { detail: payload }));
        }

        window.__getNextCsvPayload = function () {
          return queue.length ? queue.shift() : null;
        };

        function buildQueuedPayload(csv, header) {
          const sanitizedHeader = typeof header === 'string' ? header : '';
          const fileStem = sanitizeFileStem(sanitizedHeader);
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          const fileName = `${fileStem}-${timestamp}.csv`;
          return {
            csv,
            header: sanitizedHeader,
            fileName,
            receivedAt: Date.now(),
          };
        }

        function enqueueFromExternalSource(csv, header) {
          if (typeof csv !== 'string' || !csv.length) return;
          enqueuePayload(buildQueuedPayload(csv, header));
        }

        window.addEventListener('message', (event) => {
          if (!isOriginAllowed(event.origin) || !event.data) return;
          const { type, csv, header } = event.data;
          if (type !== 'table_csv' || typeof csv !== 'string') return;
          enqueueFromExternalSource(csv, header);
        });

        function consumePendingKeyFromUrl() {
          if (!window.location || !window.location.search) return null;
          try {
            const url = new URL(window.location.href);
            const key = url.searchParams.get(PENDING_PAYLOAD_QUERY_PARAM);
            if (!key) return null;
            url.searchParams.delete(PENDING_PAYLOAD_QUERY_PARAM);
            if (window.history && typeof window.history.replaceState === 'function') {
              const newRelativeUrl = url.pathname + (url.search || '') + url.hash;
              window.history.replaceState(null, '', newRelativeUrl);
            }
            return key;
          } catch (error) {
            console.warn('CSV Agent: unable to read pending payload key from URL.', error);
            return null;
          }
        }

        function collectPendingKeysFromSession() {
          if (!('sessionStorage' in window)) return [];
          const keys = [];
          try {
            for (let i = 0; i < sessionStorage.length; i++) {
              const key = sessionStorage.key(i);
              if (typeof key === 'string' && key.startsWith(PENDING_PAYLOAD_PREFIX)) {
                keys.push(key);
              }
            }
          } catch (error) {
            console.warn('CSV Agent: unable to inspect sessionStorage for pending payloads.', error);
          }
          return keys;
        }

        function consumePendingPayload(key, options = {}) {
          const context = options.context === 'url' ? 'url' : 'session';
          if (!key || !('sessionStorage' in window)) return null;
          let raw;
          try {
            raw = sessionStorage.getItem(key);
            if (raw) {
              sessionStorage.removeItem(key);
            }
          } catch (error) {
            console.warn('CSV Agent: unable to access sessionStorage for pending payload.', error);
            return null;
          }
          if (!raw) {
            if (context === 'url') {
              pushPendingNotice('CSV import payload was not found in this session. Please resend from the report page.');
            }
            return null;
          }
          try {
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed.csv !== 'string') return null;
            if (
              typeof parsed.storedAt === 'number' &&
              parsed.storedAt > 0 &&
              Date.now() - parsed.storedAt > PENDING_PAYLOAD_MAX_AGE_MS
            ) {
              console.warn('CSV Agent: pending payload expired, ignoring cached data.');
              pushPendingNotice('CSV import payload expired (kept longer than 5 minutes). Please resend from the source page.');
              return null;
            }
            return parsed;
          } catch (error) {
            console.warn('CSV Agent: invalid pending payload object.', error);
            return null;
          }
        }

        function extractTimestampFromKey(key) {
          if (typeof key !== 'string') return 0;
          const stripped = key.startsWith(PENDING_PAYLOAD_PREFIX)
            ? key.slice(PENDING_PAYLOAD_PREFIX.length)
            : key;
          const timestampPart = stripped.split('_')[0];
          const value = Number(timestampPart);
          return Number.isFinite(value) ? value : 0;
        }

        function hydratePendingPayloadFromSession() {
          const entries = [];
          const urlKey = consumePendingKeyFromUrl();
          if (urlKey) entries.push({ key: urlKey, context: 'url' });
          collectPendingKeysFromSession().forEach((key) => entries.push({ key, context: 'session' }));
          const deduped = new Map();
          entries.forEach((entry) => {
            if (!entry.key) return;
            if (!deduped.has(entry.key) || entry.context === 'url') {
              deduped.set(entry.key, entry.context);
            }
          });
          const orderedKeys = Array.from(deduped.entries())
            .map(([key, context]) => ({ key, context }))
            .sort((a, b) => extractTimestampFromKey(a.key) - extractTimestampFromKey(b.key));
          orderedKeys.forEach(({ key, context }) => {
            const payload = consumePendingPayload(key, { context });
            if (payload) {
              enqueueFromExternalSource(payload.csv, payload.header);
            }
          });
        }

        hydratePendingPayloadFromSession();

        function broadcastReady(targetWindow) {
          messageTargetOrigins.forEach((origin) => {
            try {
              targetWindow.postMessage({ type: 'ready' }, origin);
            } catch (error) {
              console.warn('Unable to notify embedding context about readiness.', { origin, error });
            }
          });
        }

        function notifyOpenerReady() {
          if (!window.opener) return;
          broadcastReady(window.opener);
        }

        function notifyParentReady() {
          if (!window.parent || window.parent === window) return;
          broadcastReady(window.parent);
        }

        if (document.readyState === 'complete') {
          notifyOpenerReady();
          notifyParentReady();
        } else {
          window.addEventListener('load', notifyOpenerReady);
          window.addEventListener('load', notifyParentReady);
        }
      })();
    </script>
  </body>
</html>

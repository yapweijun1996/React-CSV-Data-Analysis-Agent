const N=r=>{if(r==null)return null;let e=String(r).trim();if(e==="")return null;let n=!1;e.startsWith("(")&&e.endsWith(")")&&(e=e.substring(1,e.length-1),n=!0),e=e.replace(/[$\s€£¥%]/g,"");const s=e.lastIndexOf(","),o=e.lastIndexOf(".");s>o?e=e.replace(/\./g,"").replace(",","."):e=e.replace(/,/g,"");const t=parseFloat(e);return isNaN(t)?null:n?-t:t},U=r=>{if(!r||r.length===0)return[];const e=Object.keys(r[0]),n=[];for(const s of e){let o=!0;const t=r.map(c=>c[s]);let a=0;const f=r.length,d=t.filter(c=>c!==null&&String(c).trim()!=="").length;for(const c of t){const h=N(c);if(c!==null&&String(c).trim()!==""){if(h===null){o=!1;break}a++}}if(o&&a>0){const c=t.map(N).filter(A=>A!==null),h=f>0?c.length/f:0;n.push({name:s,type:"numerical",valueRange:[Math.min(...c),Math.max(...c)],missingPercentage:(1-h)*100,sampleSize:f,nonNullCount:d,numericSampleCount:c.length,numericSampleRatio:h})}else{const c=new Set(t.map(String));n.push({name:s,type:"categorical",uniqueValues:c.size,missingPercentage:f===0?0:t.filter(h=>h===null||String(h).trim()==="").length/f*100,sampleSize:f,nonNullCount:d})}}return n},E={FULL_SCAN_BLOCKED:"FULL_SCAN_BLOCKED",AGG_TIMEOUT:"AGG_TIMEOUT",COLUMN_METADATA_MISSING:"COLUMN_METADATA_MISSING",INDEXEDDB_UNAVAILABLE:"INDEXEDDB_UNAVAILABLE"},v=2e3,k=1e3,y=3e3,F=3e3,L=()=>{throw Object.assign(new Error(E.COLUMN_METADATA_MISSING),{code:E.COLUMN_METADATA_MISSING})},B=r=>{let e=0;for(let n=0;n<r.length;n++)e=(e<<5)-e+r.charCodeAt(n),e|=0;return Math.abs(e).toString(36)},b=r=>r==null?"":typeof r=="string"?r.trim():String(r),G=(r,e,n=3)=>{const s=[];for(const o of r){const t=o[e];if(t==null||t==="")continue;const a=b(t);if(a&&(s.includes(a)||s.push(a),s.length>=n))break}return s},x=async(r,e)=>{const{datasetId:n,sampleSize:s=v}=e;if(!n)throw new Error("datasetId is required for profiling.");const[o,t]=await Promise.all([r.readColumnStoreRecord(n),r.readSampledRows(n,s)]);if(o||L(),t.length===0)throw new Error("No rows available to profile.");const f=U(t).map(c=>({name:c.name,type:c.type,distinct:c.uniqueValues??new Set(t.map(h=>h[c.name])).size,emptyPercentage:c.missingPercentage??0,examples:G(t,c.name)})),d=[];return o.rowCount>t.length&&d.push(`Profiled ${t.length.toLocaleString()} rows (sample) out of ${o.rowCount.toLocaleString()}.`),{rowCount:o.rowCount,sampledRows:t.length,columns:f,warnings:d}},P=(r,e)=>!e||e.length===0?!0:e.every(n=>{const s=r[n.column],o=b(s),t=b(n.value??"");switch(n.op){case"eq":return n.caseInsensitive?o.toLowerCase()===t.toLowerCase():o===t;case"neq":return n.caseInsensitive?o.toLowerCase()!==t.toLowerCase():o!==t;case"gt":return Number(o)>Number(t);case"gte":return Number(o)>=Number(t);case"lt":return Number(o)<Number(t);case"lte":return Number(o)<=Number(t);case"contains":return o.toLowerCase().includes(t.toLowerCase());case"in":return Array.isArray(n.values)?n.values.some(a=>b(a)===o):!1;default:return!0}}),O=(r,e,n,s)=>{var T;const o=e.mode??"sample";if(!Array.isArray(e.metrics)||e.metrics.length===0)throw new Error("metrics[] is required for aggregation.");if(o==="full"&&!e.allowFullScan)throw Object.assign(new Error(E.FULL_SCAN_BLOCKED),{code:E.FULL_SCAN_BLOCKED});const t=e.by??[],a=new Map,f=((T=e.filter)==null?void 0:T.length)??0,d=(typeof performance<"u"?performance.now():Date.now())+F;for(const l of r){if(!P(l,e.filter))continue;if((typeof performance<"u"?performance.now():Date.now())>d){if(o==="full")throw new Error("AGG_TIMEOUT");break}const m=t.map(i=>b(l[i])),p=m.length>0?m.join("||"):"__total__";if(!a.has(p)){const i={};t.forEach((w,S)=>{i[w]=m[S]});const I={};e.metrics.forEach(w=>{const S=w.as??`${w.fn}_${w.column??"rows"}`;I[S]={sum:0,count:0,min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}}),a.set(p,{keys:i,accumulators:I})}const u=a.get(p);e.metrics.forEach(i=>{const I=i.as??`${i.fn}_${i.column??"rows"}`,w=u.accumulators[I];if(i.fn==="count"){w.count+=1,w.sum+=1;return}if(!i.column)throw new Error(`Metric ${i.fn} requires a column.`);const S=N(l[i.column]);S!==null&&(w.count+=1,w.sum+=S,w.min=Math.min(w.min,S),w.max=Math.max(w.max,S))})}const c=l=>{if(!l||!s)return"number";const g=s.find(m=>m.name===l);return!g||g.type==="numerical"?"number":g.type},h=[...t.map(l=>{var g;return{name:l,type:((g=s==null?void 0:s.find(m=>m.name===l))==null?void 0:g.type)??"string"}}),...e.metrics.map(l=>({name:l.as??`${l.fn}_${l.column??"rows"}`,type:l.fn==="count"?"number":c(l.column)}))],A=[];for(const l of a.values()){const g={...l.keys};e.metrics.forEach(m=>{const p=m.as??`${m.fn}_${m.column??"rows"}`,u=l.accumulators[p];let i=null;switch(m.fn){case"sum":i=u.sum;break;case"avg":i=u.count>0?u.sum/u.count:null;break;case"count":i=u.count;break;case"min":i=u.min===Number.POSITIVE_INFINITY?null:u.min;break;case"max":i=u.max===Number.NEGATIVE_INFINITY?null:u.max;break}g[p]=i??0}),A.push(g)}e.orderBy&&e.orderBy.length>0&&A.sort((l,g)=>{for(const m of e.orderBy){const p=(m.direction??"desc").toLowerCase()==="asc"?1:-1,u=l[m.column],i=g[m.column];if(u===i)continue;if(u==null)return 1;if(i==null)return-1;if(typeof u=="number"&&typeof i=="number")return u>i?p:-p;const I=String(u).localeCompare(String(i));if(I!==0)return I*p}return 0});const R=typeof e.limit=="number"?A.slice(0,e.limit):A,C=r.length,M=o!=="full"&&C<n,D=[];return M&&D.push("Aggregated on sampled rows. Retry with allowFullScan for full coverage."),{schema:h,rows:R,provenance:{datasetId:e.datasetId,sampled:M,mode:o,processedRows:C,totalRows:n,queryHash:B(JSON.stringify({by:t,metrics:e.metrics,filter:e.filter,orderBy:e.orderBy,limit:e.limit,mode:o})),filterCount:f,warnings:D}}},V=async(r,e)=>{const n=await r.readColumnStoreRecord(e.datasetId);n||L();const s=e.mode??"sample",o=s;e.mode=o;const t=e.sampleSize??y;try{const a=o==="full"?await r.readAllRows(e.datasetId):await r.readSampledRows(e.datasetId,t);if(a.length===0)throw new Error("No rows available for aggregation.");const f=O(a,e,n.rowCount,n.columns);return f.provenance.requestedMode=s,f}catch(a){if(a instanceof Error&&(a.code===E.FULL_SCAN_BLOCKED||a.message===E.FULL_SCAN_BLOCKED))throw Object.assign(new Error("Full scan requires confirmation."),{code:E.FULL_SCAN_BLOCKED});if(a instanceof Error&&a.message==="AGG_TIMEOUT"&&o==="full"){const f=await r.readSampledRows(e.datasetId,t),d=O(f,{...e,mode:"sample"},n.rowCount,n.columns);return d.provenance.warnings.push("Full scan timed out. Showing sampled results."),d.provenance.requestedMode=s,d.provenance.downgradedFrom=s,d.provenance.downgradeReason="timeout",d.provenance.warnings.push("AGG_TIMEOUT"),d}throw a instanceof Error&&a.message==="AGG_TIMEOUT"?Object.assign(a,{code:E.AGG_TIMEOUT}):a}},$=async(r,e)=>{const{datasetId:n,n:s=k,withColumns:o=!1}=e;if(!n)throw new Error("datasetId is required for sampling.");const[t,a]=await Promise.all([r.readSampledRows(n,s),o?r.readColumnStoreRecord(n):Promise.resolve(null)]);if(o&&!a&&L(),t.length===0)throw new Error("No rows available to sample.");return{rows:t,sampled:!0,columns:a==null?void 0:a.columns}};let _=null;const q=()=>typeof indexedDB<"u"&&"IDBDatabase"in self,z=async()=>{if(!q())throw new Error("IndexedDB is not available inside the worker context.");return _||(_=import("./agent_csv_csvAgentDb-Cp-wQfZT.js")),_},K=async()=>{const r=await z();return{readColumnStoreRecord:r.readColumnStoreRecord,readSampledRows:r.readSampledRows,readAllRows:r.readAllRows}},j=async r=>{const e=performance.now();try{let n;const s=await K();switch(r.action){case"profile":n=await x(s,r.payload);break;case"sample":n=await $(s,r.payload);break;case"aggregate":n=await V(s,r.payload);break;default:throw new Error(`Unknown action: ${r.action}`)}return{id:r.id,ok:!0,result:n,durationMs:performance.now()-e}}catch(n){const s=n instanceof Error?n.message:"Unknown worker error";let o,t=n==null?void 0:n.code;return n instanceof Error&&n.code==="FULL_SCAN_BLOCKED"?o="Please confirm full scan with the user, then retry with allowFullScan=true.":s.includes("IndexedDB")?(o="Browser blocked IndexedDB in this worker; falling back to main thread.",t=t??E.INDEXEDDB_UNAVAILABLE):o="Retry with a smaller sample or adjust your query.",{id:r.id,ok:!1,reason:s,hint:o,code:t,durationMs:performance.now()-e}}};self.addEventListener("message",r=>{const e=r.data;!e||typeof e.id!="string"||j(e).then(n=>{self.postMessage(n)})});export{U as p};
